
**키워드** : **프로세스, 템플릿 메쏘드, 데코레이터, 스레드(싱글,멀티), 알고리즘 3가지 종류, 리스트 컴프리헨션, 프로토타입, 이터레이터, 리스트 및 딕셔너리 컴프리헨션, 정규 표현식**

프로세스 정의:
- 쓰레드의 집합이다.
- 쓰레드 : 한 줄을 의미함

preprocess : 템플릿 메쏘드

템플릿 메쏘드: 커서가 계속 움직이는 것을 의미한다.

- 홍차와 커피를 끓이는 것을 생각하면 된다.
- 끓이는 것은 메쏘드
- 홍차 또는 커피 또는 녹차 등등 바꿔 놓으면 된다.
- 템플릿 메쏘는 스테틱 메쏘드의 실행 순서를 정해준다. 스테틱 메쏘드는 순서가 상관이 없다. 

템플릿 메쏘드 정형화된 버전(어떤 문제를 풀던 아래 사진까지 동일하다.)
![[Pasted image 20250218101900.png]]

아토믹 패턴 - 디자인 패턴의 기본이다. 

데코레이터..?

파라미터는 아규먼트와 같아야한다.


스레드는 커서의 움직임을 의미한다.(실로 비유)

싱글 스레드 
-  노래 듣다가 전화하려면 노래가 끊긴다. 
-  하나의 실행 흐름(Thread)만을 가지는 프로세스

멀티 스레드 
-  노래 듣다가 전화가 가능하다.
-  CPU를 여러 개이면 멀티 스레드가 가능하다.
-  여러 작업을 동시에 수행할 수 있는 프로세스를 의미함

스테틱 메쏘드
- 고정적인 메쏘드이다. 텀블러처럼 일회성이 아니다.

다이나믹 메쏘드
- 동적인 메쏘드이다. 종이컵이다. 일회성이다.

#### 알고리즘 3가지 종류
### **1. 분할 정복 알고리즘 (Divide and Conquer, DC)**

- 큰 문제를 여러 개의 작은 문제로 나눈 뒤, 각 문제를 해결하고 결과를 합쳐서 최종 해답을 도출하는 방식.

### **2. 동적 계획법 (Dynamic Programming, DP)**

- **작은 문제들의 해결 결과를 저장**하고, 이를 활용하여 전체 문제를 해결하는 기법.

### **3. 탐욕 알고리즘 (Greedy Algorithm)**

- 각 단계에서 **가장 최적의 선택(Locally Optimal Choice)**을 반복하여 최종 해답을 도출하는 방식.


##### 리스트 컴프리헨션(List Comprehension)

-  짧고 간결한 문법으로 리스트를 생성하는 방법
-  커서를 이해시키려고 한다.
- 아래는 아스타가 있으니까 리스트 컴프리헨션으로 쓸 수 있다.

![[Pasted image 20250218111524.png]]

그리고 아래처럼 한 줄로 바꿨다. 이것을 리스트 컴플리헨션이다. 
![[Pasted image 20250218112531.png]]



....객체는 공간이 남아있으니까, 안에서 연산을 하면 된다.

##### **생성 패턴 5가지 종류**

- 프로토타입(원본)
-  팩토리
-  추상 팩토리
-  싱글턴
-  빌더

이터레이터
-  순환을 생각하면 된다.

자료구조에는 리스트와 딕셔너리가 있다.



**딕셔너리 컴프리헨션**

- **한 줄의 코드로 딕셔너리를 생성하는 방법**입니다.


[for j in for i in [this.train, this.test]]

- train과 test의 feauture가 똑같으므로 같이 쓸 수 있다.


# Inplace = True에 대한 설명

`inplace`는 **객체를 직접 수정할지 여부를 결정하는 옵션**으로, 파이썬의 여러 라이브러리(특히 `pandas`나 `numpy` 등)에서 자주 사용됩니다.

- `inplace=True`: 기존 객체를 **직접 수정**하고, 반환값이 `None`이 됨.
- `inplace=False` (기본값: 디폴트): 기존 객체는 그대로 두고, **새로운 객체를 반환**.

inplace : 일괄처리 되는 것


아래 사진에 있는 코드를 컴프리헨션 하기 전이다. 
![[Pasted image 20250218114506.png]]

아래 사진은 컴프리헨션을 한 후 이다. 이건 리스트 컴프리헨션이다. 
![[Pasted image 20250218114616.png]]

null_check는 빈 셀을 체크하는 것이다.


complihension에서 무조건 inplace = True를 사용한다. inplace = False는 아래와 같은 구조를 가진다. 즉, 할당을 준거다.... '='을 이용해서.......

![[Pasted image 20250218123427.png]]

그리고 inplace = True는 아래와 같은 구조를 가질 때...complihension을 사용할 때, 쓴다.
![[Pasted image 20250218123516.png]]

inplace = True도 앞에 할당을 준거지만, 표시를 안 한 것 뿐이다. 인터프리터가 위에 사진을 읽을 것이다. 

아래는 딕셔너리 컴프리헨션이니까...왜냐하면 ** (아스타가 두 개)이니까...아래는 감쌀 때, 컬브레이스(중괄호)로 감싼다.

![[Pasted image 20250218125528.png]]

![[Pasted image 20250218125226.png]]

키워드가 연속으로 ..만약 5개 면 키워드가 연속으로 나온다.......
![[Pasted image 20250218125916.png]]

패턴 코딩(Pattern Coding)
- **특정한 규칙(패턴: 디자인 패턴(Design Patterns))에 따라 프로그램을 작성하는 기법**을 의미함.

##### inplace와 mapping의 차이점

- a= [ ]일 경우, a = [1, 2, 3] 으로 일괄 바꾸면, inplace 라고 한다. inplace는 있는 것을 새걸로 바꾸는 것을 의미함.
- 일괄 바꾸는 게 아니라, 조건에 따라 바꾸는 것을 mapping이라고 한다.

[ ] 여기 안에 들어갈 수 있는 것은 정수와 str이다.
[ ] 안에 정수가 들어가 있으면 리스트이다. [ ] 안에 문자열이 들어가 있으면 딕셔너리이다.

자료구조는 리스트(복수)와 딕셔너리(복수)이다. 


print {'a', 'b'} => b(값)= [' a '](키)

these['Name'].str.extract('([**A-Za-z]+**)\.', expand=False)
A-Za-z 값을 의미함.
+값이 하나 이상 있는 것을 의미함.
'\.' 글자 다음에 점


```python
from com.kimdonghee.models.titanic.dataset import Dataset        # 자료는 데이터셋에서 가져오겠다는 뜻이다. from "파일명", import "class"
import pandas as pd # pd = Pandas  #pandas는 데이터 분석 및 처리하는 라이브러리를 의미함.

class TitanicService:

    dataset = Dataset()   #Dataset()을 dataset이라고 이 안에서 부르겠다는 의미이다.

    def new_model(self,fname) -> object: #self는 자기 데이터를 가지고 오겠다라는 의미. #new_model은 모델을 만드는 것을 의미함. fname이라는 파일명을 받고 object에 결과를 찍겠다
        this = self.dataset #self가 붙으면 property인 것을 알수 있다. 그리고 self.dataset을 this라고 설정하였다.
        this.context = 'C:\\Users\\bitcamp\\Documents\\titanic250207\\com\\kimdonghee\\datas\\titanic\\' #this라는 데이터 셋에 'C:\\\\Users\\bitcamp\\OneDrive\\문서\\titanic\\com\\kimdonghee\\datas\\titanic\\\\'라는 경로를 주겠다는 것이다.
        this.fname = fname #파일명만 유일하게 바깥에서 가져올 수 있다.
        return pd.read_csv(this.context + this.fname)
    
    def preprocess(self, train_fname, test_fname) -> object:
        print("---------모델 전처리 시작 ----------")
        feature = ['PassengerId', 'Survived', 'Pclass', 'Name', 'Sex', 'Age', 
                   'SibSp', 'Parch', 'Ticket', 'Fare', 'Cabin', 'Embarked']
        this = self.dataset
        this.train = self.new_model(train_fname)
        print("트레인 데이터")
        #ic(this.train) #ic는 프린터하는 기능이다.
        print(this.train)
        this.test = self.new_model(test_fname)
        print("테스트 데이터")
        #ic(this.train)
        this.id = this.test['PassengerId'] #테스트는 중간고사, 기말고사이고, 트레인은 매일 쪽지 시험 느낌////
        #'SibSp', 'parch'. 'Cabin', 'Ticket'가 지워야 할 feature 이다.
        drop_features = ['SibSp', 'Parch', 'Cabin', 'Ticket']
        this = self.extract_title_from_name(this)
        title_mapping = self.remove_duplicate_title(this)
        this = self.title_norminal(this, title_mapping)
        this = self.drop_feature(this,'Name')
        this = self.gender_nominal(this)
        this = self.drop_feature(this,'Sex')
        this = self.embarked_norminal(this)  
        self.df_info(this)
        this = self.age_ratio(this)
        this = self.drop_feature(this,'Age')
        this = self.pclass_ordnal(this)
        this = self.fare_ratio(this)
        this = self.drop_feature(this,"Fare")

        return this
    
    @staticmethod #staicmethod는 함수가 아니다.
    def create_labels(this) -> object:
        return this.train['Survived'] #this는 self.dataset을 변화시키려고 만든 것이다.
    
    @staticmethod
    def create_train(this) -> object:
        return this.train.drop('Survived', axis= 1) #Survived 답을 제거해야하니까.....그리고 이 함수는 답인지 알려줘야하니까 썼다.
    
    @staticmethod
    def drop_feature(this, *feature) -> object: #피쳐를 통해서 베러블을 가공시키겠다.... *표시와 같이 있으면 두번 묶는다는 것을 의미함. 리스트를 아규먼트로 보내면, 두개로 묶어지는 거다.....
        
        [i. drop(j, axic=1) for j in feature for i in [this.train, this.test]]

        # for i in [this.train, this.test]:
        #     for j in feauture:
        #         i.drop(j, axis=1, inplace=True)
        return this
    @staticmethod
    def df_info(this):    #this는 인간이 보는 것, self는 기계가 보는 것
        return this

    @staticmethod
    def extract_title_from_name(this):      
        return this
    
    
    @staticmethod
    def remove_duplicate_title(this):
        return this

    @staticmethod
    def kwargs_sample(**kwargs) -> None:
        {print(''.join(f'키워드 arg: {i} 값: {j}')) for i, j in kwargs.items()}

    @staticmethod
    def null_check(this):
        [print(i.isnull().sum()) for i in [this.train, this.test]]

    @staticmethod
    def title_norminal(this):      
        return this
    
    @staticmethod
    def pclass_ordnal(this):      
        return this

    @staticmethod
    def gender_nominal(this):
        [print(i.sum()) for i in [['1','2','3'], {"1":1,"2":2,"3":3}]]
        return this

    @staticmethod
    def age_ratio(this):
        return this

    @staticmethod
    def age_ratio(this):
        return this

    @staticmethod
    def fare_ratio(this):
        return this

    @staticmethod
    def embarked_norminal(this):
        #embarked = this.train.fillna({'Embarked': 's'}) #fill채워라 NaN을..... ['Embarked'] 형태는 키만 가지고 있는 상태를 의미함. #'S'는 S라는 항구가 가장 많이 탔다. 
        this.train = this.train.fillna({'Embarked': 'S'})
        this.test = this.test.fillna({'Embarked': 'S'})
        this.train['Embarked'] = this.train['Embarked'].map({'S':1, 'C':2, 'Q':3})
        this.test['Embarked'] = this.test['Embarked'].map({'S':1, 'C':2, 'Q':3})
        return this

# 데이터 셋에서 만들었던 객체들을 경로를 가져온 클래스 하는 작업...
# reuse하는 작업 ..get unit count!!
# 파일을 불러오는 작업
# 객체를 형성하는 작업((메모리를 로딩시켜서 사람이 볼수있는 상태로 만들어주는 것이다.))
```

정규 표현식

메타문자 : 특수 기호를 의미한다.

일반문자: 일상적인 문자

신택스 - 

와일드 카드 - 아스타( * )를 의미함.

. 하위항목


[정규 표현식](https://ko.wikipedia.org/wiki/%EC%A0%95%EA%B7%9C_%ED%91%9C%ED%98%84%EC%8B%9D)

![[Pasted image 20250218155151.png]]


### 리스트와 딕셔너리

i = 0 에서 i는 인트...인트는 정수이다. 여기에서 i=0이라고 주어지고, 0이라고 값을 매겼을 때, i는 정수이다. 인트이다...정수는 인트

i=0.1 에서 i는 소수이다. 소수는 플로트이다. 그래서 i는 플로트이다.

i = "0.1" 에서 0.1은 문자이다. i는 스트링이다. 

i[0] 에서 i는 리스트이다. 왜냐하면 ""이 없다. 

i["0"] 에서 i 는 딕셔너리이다. 왜냐하면 뒤에 ""이 있다.

그리고 i["0"]는 리스트를 의미한다. i ["0"] [0] 에서 0은 index이다.....자꾸 생략이 되서 ...클릭해서 봐야함..

딕셔너리일 때는 expand = True여야한다. 리스트일때는 expand = False이어야 한다.
 
 데이터프레임은 딕셔너리, ......

__ __ 이 표시는 미리 만들어진 것....내장되어 있는 메소드 이다. 

함수는 객체 호출할 필요 없이 쓸 수 있다. 

### 파이썬에서 중복을 제거하는 자료구조

set이라는 함수를 이용하여  중복 제거 함수 사용하면 된다.

Q....허프만은 숫자 할당하려고 한다...이게 무슨 말이야?


``` python
1. Train 의 type
 <class 'pandas.core.frame.DataFrame'>
2. Train 의 column
 Index(['PassengerId', 'Pclass', 'Name', 'Sex', 'Age', 'SibSp', 'Parch',
       'Ticket', 'Fare', 'Cabin', 'Embarked', 'Title'],
      dtype='object')
3. Train 의 상위 1개 행
    PassengerId  Pclass                                               Name     Sex   Age  SibSp  Parch            Ticket     Fare Cabin  Embarked  Title
0            1       3                            Braund, Mr. Owen Harris    male  22.0      1      0         A/5 21171   7.2500   NaN         1      1
1            2       1  Cumings, Mrs. John Bradley (Florence Briggs Th...  female  38.0      1      0          PC 17599  71.2833   C85         2      3
2            3       3                             Heikkinen, Miss. Laina  female  26.0      0      0  STON/O2. 3101282   7.9250   NaN         1      2
3            4       1       Futrelle, Mrs. Jacques Heath (Lily May Peel)  female  35.0      1      0            113803  53.1000  C123         1      3
4            5       3                           Allen, Mr. William Henry    male  35.0      0      0            373450   8.0500   NaN         1      1
4. Train 의 null 의 갯수
 PassengerId      0
Pclass           0
Name             0
Sex              0
Age            177
SibSp            0
Parch            0
Ticket           0
Fare             0
Cabin          687
Embarked         0
Title            0
dtype: int64개
5. Test 의 type
 <class 'pandas.core.frame.DataFrame'>
6. Test 의 column
 Index(['PassengerId', 'Pclass', 'Name', 'Sex', 'Age', 'SibSp', 'Parch',
       'Ticket', 'Fare', 'Cabin', 'Embarked', 'Title'],
      dtype='object')
7. Test 의 상위 1개 행
    PassengerId  Pclass                                          Name     Sex   Age  SibSp  Parch   Ticket     Fare Cabin  Embarked  Title
0          892       3                              Kelly, Mr. James    male  34.5      0      0   330911   7.8292   NaN         3      1
1          893       3              Wilkes, Mrs. James (Ellen Needs)  female  47.0      1      0   363272   7.0000   NaN         1      3
2          894       2                     Myles, Mr. Thomas Francis    male  62.0      0      0   240276   9.6875   NaN         3      1
3          895       3                              Wirz, Mr. Albert    male  27.0      0      0   315154   8.6625   NaN         1      1
4          896       3  Hirvonen, Mrs. Alexander (Helga E Lindqvist)  female  22.0      1      1  3101298  12.2875   NaN         1      3개
8. Test 의 null 의 갯수
 PassengerId      0
Pclass           0
Name             0
Sex              0
Age             86
SibSp            0
Parch            0
Ticket           0
Fare             1
Cabin          327
Embarked         0
Title            0
dtype: int64개
```


타이타닉 데이터에서 제공되는 각 열(`column`)의 의미는 다음과 같음.


1. PassengerId`**: 각 승객에게 부여된 고유한 식별 번호. 
2. Pclass`**: 승객이 탑승한 선실 등급 (1 = 1등석, 2 = 2등석, 3 = 3등석).
3. **`Name`**: 승객의 전체 이름.
4. **`Sex`**: 승객의 성별 (`male`, `female`).
5. **`Age`**: 승객의 나이.
6. **`SibSp`**: 함께 탑승한 형제자매(Sibling) 및 배우자(Spouse)의 수.
7. **`Parch`**: 함께 탑승한 부모(Parent) 및 자녀(Children)의 수.
8. **`Ticket`**: 승객의 티켓 번호.
9. **`Fare`**: 승객이 지불한 운임 요금.
10. **`Cabin`**: 승객이 배정 받은 객실 번호 (일부 누락됨).
11. **`Embarked`**: 승객이 탑승한 항구 (`C = Cherbourg`, `Q = Queenstown`, `S = Southampton`).
12. **`Title`**: 이름에서 추출한 승객의 직위 또는 호칭 (`Mr.`, `Mrs.`, `Miss.`, `Master.` 등).


### 테스트 및 트레인

-  테스트: 우리가 학습시킨 모델을 제대로 작동하는지 확인하는 과정...

-  트레인: 테스트를 받기 위해 훈련시키는 과정을 의미함,,,,  

norminal 과 ordinal의 차이
: 순서의 유무이다. 노미널은 순서가 중요하다. 


### inplace와 expand의 차이

: 둘 다 모두 complihension 구조에서 쓰인다. 하지만, inplace는 원래 있던 객체를 변환시킬 때, 사용되어지고, expand는 새로 추가할 때 쓰인다.


1) inplace = True인 경우
예를 들어, 아래 구조는 inplace가 쓰이는 때이다. 여기에서 아래 첫 행을 보면 inplace = true가 쓰였다. inplace =true형태일 때는 앞에 예를 들어,,, 'a = 3' 처럼 a라는 변수이름을 지정해주지 않았다. 하지만, a는 숨어있다...... 
```python
 [i. drop(j, axis = 1) for j in feature for i in [this.train, this.test]]

  

        # for i in [this.train, this.test]:

        #     for j in feauture:

        #         i.drop(j, axis=1, inplace=True)

        return this
```

2) inplace =False인 경우(디폴트의 값)
우리가 평소에 쓰던 함수 식이랑 같다...우리는 this 라는 변수 이름을 주고 아래처럼 함수 식을 만들었다. 이런 경우는 inplace = False와 같다.
```python
this = self.drop_feature(this,'Name')

        this = self.gender_nominal(this)
```

3) "expand = False"인 경우

 이 경우는 시리즈이고 리스트 일 때, 사용한다.

4) "expand = True"인 경우

이 경우는 딕셔너리 일 때, 사용한다.


### preprocess 함수 이해

```python
def preprocess(self, train_fname, test_fname) -> object:

        print("---------모델 전처리 시작 ----------")

        feature = ['PassengerId', 'Survived', 'Pclass', 'Name', 'Sex', 'Age',

                   'SibSp', 'Parch', 'Ticket', 'Fare', 'Cabin', 'Embarked']

        this = self.dataset

        this.train = self.new_model(train_fname)

        print("트레인 데이터")

        #ic(this.train) #ic는 프린터하는 기능이다.

        print(this.train)

        this.test = self.new_model(test_fname)

        print("테스트 데이터")

        #ic(this.train)

        this.id = this.test['PassengerId'] #테스트는 중간고사, 기말고사이고, 트레인은 매일 쪽지 시험 느낌////

        #'SibSp', 'parch'. 'Cabin', 'Ticket'가 지워야 할 feature 이다.

        this.label = this.train['Survived']

        this.train = this.train.drop('Survived', axis = 1)

        drop_features = ['SibSp', 'Parch', 'Cabin', 'Ticket']

        this = self.extract_title_from_name(this)

        title_mapping = self.remove_duplicate_title(this)

        this = self.title_nominal(this, title_mapping)

        this = self.drop_feature(this,'Name')

        this = self.gender_nominal(this)

        this = self.drop_feature(this,'Sex')

        this = self.embarked_norminal(this)  

        self.df_info(this)

        this = self.age_ratio(this)

        this = self.drop_feature(this,'Age')

        this = self.pclass_ordnal(this)

        this = self.fare_ratio(this)

        this = self.drop_feature(this,"Fare")

  

        return this
```

**타이타닉 데이터의 전처리(preprocessing)** 를 수행하는 메서드입니다. 데이터 전처리는 머신러닝 모델을 학습시키기 전에 불필요한 데이터를 제거하고, 필요한 변수를 변환하는 과정이다.

- `train_fname`: 훈련 데이터 파일명 (ex. `'train.csv'`)
- `test_fname`: 테스트 데이터 파일명 (ex. `'test.csv'`)
- `self.dataset`: 데이터를 저장하는 객체 (`self`는 클래스 내부의 메서드임)
- 반환값: 전처리된 데이터(`this` 객체)

이 함수는 **훈련 데이터(`train.csv`)와 테스트 데이터(`test.csv`)를 불러와 전처리를 수행한 후, 전처리된 데이터셋을 반환**합니다.

## **📌 주요 전처리 단계**

### **1. 데이터 로드**

```python
feature = ['PassengerId', 'Survived', 'Pclass', 'Name', 'Sex', 'Age', 'SibSp', 'Parch', 'Ticket', 'Fare', 'Cabin', 'Embarked'] this = self.dataset this.train = self.new_model(train_fname) this.test = self.new_model(test_fname)
```

- `feature`: 사용할 컬럼을 지정.
- `self.new_model(train_fname)`, `self.new_model(test_fname)`: 데이터 파일을 불러와 `this.train`과 `this.test`에 저장.

✅ **즉, `train.csv`와 `test.csv` 데이터를 `this.train`과 `this.test`에 저장하는 과정**.

### **2. 학습 데이터와 테스트 데이터 구분**

`this.id = this.test['PassengerId'] this.label = this.train['Survived'] this.train = this.train.drop('Survived', axis=1)`

- `this.id = this.test['PassengerId']`: **테스트 데이터의 승객 ID 저장** (테스트는 답이 없으므로 `Survived`가 없음).
- `this.label = this.train['Survived']`: **타겟(label) 값(생존 여부)을 저장**.
- `this.train = this.train.drop('Survived', axis=1)`: **훈련 데이터에서 `Survived` 컬럼을 삭제** (모델이 예측할 대상이므로 삭제).

✅ **즉, 훈련 데이터에서 `Survived` 컬럼을 따로 저장하고 삭제하여 입력 데이터만 남김**.

---

### **3. 불필요한 Feature 제거**


`drop_features = ['SibSp', 'Parch', 'Cabin', 'Ticket']`

- `drop_features` 리스트를 생성.
- 이 변수들은 머신러닝 모델에서 **중요한 영향을 주지 않는다고 판단**하여 제거 예정.

---

### **4. Name에서 Title 추출**

`this = self.extract_title_from_name(this) title_mapping = self.remove_duplicate_title(this) this = self.title_nominal(this, title_mapping) this = self.drop_feature(this,'Name')`

- `extract_title_from_name()`: `Name` 컬럼에서 승객의 **호칭(Title)** 을 추출 (예: `Mr.`, `Miss.`, `Dr.` 등).
- `remove_duplicate_title()`: **유사한 호칭을 통합** (예: `Mme` → `Mrs`).
- `title_nominal()`: **호칭을 숫자로 변환** (`Mr: 1, Mrs: 2, Miss: 3` 등).
- `drop_feature(this, 'Name')`: **이제 필요 없는 `Name` 컬럼 삭제**.

✅ **즉, 이름에서 유용한 정보를 추출한 후, 원래 `Name` 컬럼은 삭제**.

---

### **5. 성별(Sex) 변환**

`this = self.gender_nominal(this) this = self.drop_feature(this,'Sex')`

- `gender_nominal()`: **`Sex` 값을 숫자로 변환** (`male: 0, female: 1`).
- `drop_feature(this, 'Sex')`: **`Sex` 컬럼 삭제** (이미 변환되었으므로 불필요).

✅ **즉, 성별을 숫자로 변환하고 원래 컬럼 삭제**.

---

### **6. 탑승 항구(Embarked) 변환**

`this = self.embarked_norminal(this)`

- `Embarked`(탑승한 항구) 컬럼을 **숫자로 변환** (`C: 0, Q: 1, S: 2`).

✅ **즉, 탑승 항구 데이터를 모델이 이해할 수 있도록 변환**.

---

### **7. 나이(Age) 데이터 처리**

`this = self.age_ratio(this) this = self.drop_feature(this,'Age')`

- `age_ratio()`: **나이(Age)를 특정 그룹(구간)으로 변환** (`0-10세: 0, 11-20세: 1` 등).
- `drop_feature(this, 'Age')`: **원래 `Age` 컬럼 삭제**.

✅ **즉, 나이를 범주형 변수로 변환한 후, 원래 `Age` 컬럼 삭제**.

---

### **8. Pclass(객실 등급) 변환**

`this = self.pclass_ordnal(this)`

- **객실 등급(Pclass)을 숫자로 변환** (`1등급: 0, 2등급: 1, 3등급: 2`).

✅ **즉, 객실 등급을 모델이 쉽게 이해할 수 있도록 변환**.

---

### **9. 운임(Fare) 데이터 처리**

`this = self.fare_ratio(this) this = self.drop_feature(this,"Fare")`

- `fare_ratio()`: **운임 요금을 특정 그룹(구간)으로 변환** (`0-10$: 0, 11-50$: 1` 등).
- `drop_feature(this, 'Fare')`: **원래 `Fare` 컬럼 삭제**.

✅ **즉, 운임을 범주형 변수로 변환한 후, 원래 `Fare` 컬럼 삭제**.

---

### **10. 최종 반환**

`return this`

- **전처리가 완료된 데이터(`this`)를 반환**.

---

## **📌 최종 정리 (전처리 과정)**

1. **데이터 불러오기** (`train.csv`, `test.csv`).
2. `Survived` 컬럼을 따로 저장하고 훈련 데이터에서 제거.
3. `SibSp`, `Parch`, `Cabin`, `Ticket` **삭제**.
4. `Name`에서 **Title(호칭) 추출** 후 `Name` 컬럼 삭제.
5. `Sex`를 숫자로 변환 후 원래 컬럼 삭제.
6. `Embarked`를 숫자로 변환.
7. `Age`를 그룹화하여 변환 후 원래 컬럼 삭제.
8. `Pclass`(객실 등급) 변환.
9. `Fare`(운임 요금)를 그룹화하여 변환 후 원래 컬럼 삭제.
10. **전처리 완료된 데이터 반환**.

🚀 **결론: 이 함수는 타이타닉 데이터를 머신러닝 모델이 학습하기 쉬운 형태로 변환하는 과정**을 수행합니다.