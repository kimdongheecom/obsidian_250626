

user, admin - 도메인 모델이라고 한다.

전부 본질은 같은데, 용어만 다르다는 것을 의미한다. - aspect

### skima

- **심리학**(맥락 또는 컨텍스트)**에서의**(관점) 스키마
- 데이터베이스에서의 스키마
- API 스키마(API에서의 스키마는 도메인이라고 한다.)
- 인지 과학에서의 스키마
- 언어학에서의 스키마
- 인공지능에서의 스키마



컨텍스트는 환경변수라고 한다. 

### 컨텍스트(Context)가 뭐야? 


### 완전체와 객체와 개체

완전체: 기능과 속성의 집합

기능 빼고 속성만 있으면 개체
기능이 없으면 속성이 변할 수 없다. 상수가 된다.

기능과 속성이 있으면 객체
기능이 있으면 속성이 변한다.


환경 - space

### Legacy


fastAPI는 인공지능 AI를 대응하는 프레임워크이다.

플라스크는 그에 비해 Legacy(레거시)이다. 플라스크는 경차 느낌이다. 장고는 트럭느낌이다. 짐만 많이 싫는 느낌이다.

FastAPI에서 **Legacy**는 주로 **기존의 오래된 코드나 시스템**을 의미해. FastAPI 자체는 **최신 웹 프레임워크**이지만, 기존의 **Django, Flask, 또는 다른 오래된 API 시스템(legacy system)**과 함께 사용해야 하는 경우가 많아.




### fastAPI
- 메인 라우터와 서브 라우터 두 개 있다.
- 라우터는 클래스가 없기 때문에, oop(객체지향 프로그램)가 아니고 항상 존재하는 느낌이다. 라우터는 항상 함수이다. 메소드가 아니다. 
-  함수형 프로그램: 클래스를 걷어 낸 것을 의미함.




상태는 속성에 저장된다. 속성이 없다.  init안에 변수가 없다. self는 내 꺼에서 바뀌는 것이고, this는 남의 것을 받아서 변경하는 것이다.


### 라우터

라우터 - init이 없는 세상. 셀프와 디스가 없는 세상이다.


fastAPI의 장점

- 앱과 웹의 자유로운 전환이 가능하다.
- 

class내에서 속성을 만들듯이 한 폴더 내에ㅓ도.......
클래스 내에서 공통적으로 ㅏ용할 속성값을 저으이 하듯이

클ㄹ스 내에 글로벌 ㅁ

ㅁ델이라는 폴ㄹ더를 구

프렉탈 구조


init/////////////////////////////////

프렉탈 때문에 쓴다. 

클래스 내부에 init 안에 있었는데, 



**폴더가 인스턴스 일 때, 그 폴더를 모듈이라고 한다.**

모듈은 인스턴스 이다.
모듈은 디렉토리 개념에서 객체 개념 이다. 

객체가 되야하니... init.py를 만들어야 한다. 





### 절차 지향 프로그램잉(1970 - 1990) (정)

- c언어 사용함

- 호출 되는게 아니라, 순서대로 진행되는 것을 의미함. 커멘드 창에 코딩하는 것을 말함.

### 객체 지향 프로그램잉 OOP (1995 - Java) (반) 자바는 객체지향에 최적화함.
- java 사용함

### 함수형 프로그램잉 (합)

AA; 아키텍쳐 책임자
DBA: 데이터베이스 책임자
CTO: 최고 기술 책임자


OOP는 호출 구조이다. 

클래스

클래스 구성:  함수와 메소드로 나뉜다.

클래스 종류: 클래스와 추상 클래스가 있다.


추상 클래스: 
- 인스턴스를 생성할 수 없는 클래스를 의미함. <-> 디폴트 클래스(구상 클래스)
- 계속 바뀐다.

구상 클래스 
- 이 놈이 스테틱이다. 한번 만들면 바뀌지 않는 것.
- '캡슐화'를 의미함.


소나타

추상 클래스:  교체 가능한 부분을 추상 클래스 라고 한다. 예) 타이어, 서비스에서의 라우터이다..... 교체할 수 있도록 길을 내주는 분기점 같은 느낌이다.


추상팩토리: 설계도,

추상: 키오스크에서 1955버거 그림,

팩토리: 버거가 직접 나온다.

db가 연결되어이는 녀석 레파지토리

화면이 연결되어 있는 녀석이 뷰이다.





구상 클래스: 


컨트롤러는 라우터와 컨트롤러로 나뉜다.







인터페이스 

웹 
- 무조건 3개이다.

라우터 무조건! 리쿼스트는 라우터에서 스톱!

서비스에 전달해주는 것은 컨트롤러! 


에드 하나에 대한 요청이 레파지토리로 간다. 

팩토리!



레파지토리는 디비와 연결이 된다. 디비에서 값을 처리한다.


컨트롤러를 통해서 서비스에 연결한다. 

### 네이밍 컨벤션
- **네이밍 컨벤션(Naming Convention)**은 **코드에서 변수, 함수, 클래스, 파일, 디렉토리 등의 이름을 정하는 일관된 규칙**이야.

클래스는 구상과 추상으로 나뉜다.

구상: 모양이 다름에 있다. 

클래스

- 구상은 init이 있다
-  init이 없다면


### 상속(객체지향 4가지 특징 중 3번째)

- 상속(Inheritance)**은 **기존 클래스(부모 클래스)의 속성과 메서드를 새로운 클래스(자식 클래스)가 물려받는 개념**이야. 재사용 개념이다.


**추상 클래스는 부모 클래스(Superclass)이다.**
#### **✅ 이유**

- 추상 클래스(`Abstract Class`)는 **공통적인 기능을 정의하고, 자식 클래스가 이를 반드시 구현하도록 강제하는 부모 클래스**야.



### **메타인지(Metacognition)란?**

**메타인지(Metacognition)**는 **자신의 사고(생각) 과정을 스스로 인식하고 조절하는 능력**을 의미해.
자기 스스로 인식한다. 


### 메타클래스란?

**메타클래스(Metaclass)**는 **클래스를 상속하는 클래스**야.
메타 클래스는 부모이다. 

상속문법 : '( )'

![[Pasted image 20250227143554.png]]


자식에게 부모의 속성과 메서드를 다 준다. 이유는 부모한테 있는 코딩을 또 코딩하지 말자는 의미에서.....

```python
class PetroService #자식(metaclass아빠=ABCMeta#영호): #추상 클래스이다. 함수가 아니고 메소드이다.

    def __init__(self):

        pass
```


객체지향은 클래스 만드는 방법에 대해 말해주고 있다.

### 추상과 구상

추상:

구상: 

메소드의 기능은 @로 표시한다.

### 핸들러 패턴
- 커멘드 패턴이다. 명령하는 것을 의미함. 

### 콜백 함수
- 전략, 옵저버



hadle 명령이 에드가 되고 바귀는 거다. 명령 체계이다. 나는 명령을 수행했다. 

클래스 만드는 것이 캡슐화이다. 캡술화는 구상 클래스를 만드는 것이다. 인잇이 있어야되니까. 캡슐화는 인잇이ㅣ

추상 클래스는 추상에 관한 것이다. 


아래 사진은 추상화이다.
![[Pasted image 20250227151004.png]]

추상화: abstracttion이라고 한다.



### strategy: 

- 특정 행동을 하는 인스턴스이고, 그 다음에 딕셔너리로 만든다. 
- 브랜치를 제거하는 것이다.
- 메소드를 클래스로 만든 후에 인스턴스로 만드는 것이다. 최종적 보관은 딕셔너리이다. 
- 포스트랑 겟방식도 전략패턴이다. 걔네도 키로 메소드를 호출하기 때문에, 전략패턴이다.
-



메소드를 클래스로 ㅎㅆ고, 그거를 인스턴스화 한게 전략이다.

전략 패턴 = 'method = ['POST', 'GET']

ㅈ듀: 사용자의 리\\\




라우터간다음 컨드롤러 간다음 펙토리에서 요청된 전략을 가지고, 서비스로 간다. 

메소드를 캡슐화 한다는 것은 클래스로 만들어서 인스턴스화 시킨다는 것이다.

캡슐화 하는 것은 전략화시키는 것이다. 인스턴스화시키는 것을 팩토리라고 한다. 

인스턴스화한것까지가 전략패턴이다....

"메인 라우터"  -> "서브 라우터"  -> "컨트롤러"  -> "팩토리" 이 과정에서 웹(Web)이 끝난다. 이 부분까지 사용자 요청이 여기서 웨이팅 하는 것이 된다.




AbstractUser - 추상 클래스(부모 클래스), 우린 이걸 인터페이스라고 부른다. 
add_user, delete_user, get_all_user 등등 추상 클래스 아래에 있는 것들은 자식 클래스이다. 자식 클래스를 서브 클래스라고 하고, 우리는 strategy라고 부른다. 추상클래스를 상속 받게 하는 것을 추상화라고 한다. 추상클래스의 자식들은 strategy가 될 녀석들이다.

![[Pasted image 20250227192718.png]]

캡슐화 - 클래스로 쪼갠 것을 의미함.

- 클래스라는 단어가 없으면 캡슐화가 아니다. 클래스가 들어와야 객체지향이다. 
- 클래스가 없으면 함수형

클래스는 구상 클래스와 추상 클래스가 있다.


### 캡슐화 vs 추상화
class AddUser: (캡슐화)
class AddUser(AbstractUser): 추상화


### 생성자 vs 함수 vs 메소드

생성자: User( )
함수: user( )
메소드 : user.test( )


### 전략 패턴
추상 클래스를 만들어서 서브 클래스를 만들어. 그리고 서브 클래스를 인스턴스화 해서, 스트레티지가 된다. 딕셔너리 안에 키를 담는다. 
딱 거기까지 한 것을 전략 패턴이라고 한다. 



### model부분

- user_entity.py 이 모델은 데이터 베이스(DB) 박스로 들어감.
- user_schema.py 이 부분은 객체 프로그램으로 들어감. 기존 겟터,셋터가 들어가 있는 부분이었다.

### 클래스

#### 종류
- 구상 클래스:  지금까지 우리가 만든 클래스는 구상 클래스이다. 예시) class AddUser:  
- 추상 클래스:  오늘 추가로 만든 것... 예시) class AddUser(AbstractUser): 부모 자식간의 관계가 나타나있다. adduser는  서브클래스이고, AbstractUser는 추상 클래스(부모 클래스)이다. 

#### 구성요소
- 함수: 예) a( )
- 메소드: 예) app. path( )

OOP객체 지향 프로그램


### 스키마
스키마: 도메인