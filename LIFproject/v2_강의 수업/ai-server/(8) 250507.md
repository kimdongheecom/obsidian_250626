

플랫폼: 프레임워크와 라이브러리의 집합이다.


.csv, .ckpt, .xml 이러한 파일들은 학습이 되어있는 모델이다.

cv2: 시각화 할 수 있는 모델이다.

ml과 dl의 차이점: nn(뉴런 네트워크)의 유무이다.


제프리 힌튼

- 역전파와 순전파

#### 데이터의 움직임(순전파와 역전파 모두 동일함)
- 노드가 움직이는게 아니라, 엣지를 통해서 데이터가 움직인다.
#### 순전파 vs 역전파
- 순전파: 옵티마이저를 통해 모델(결과물, 즉 파일)이 나온다.
	- 순전파는 입력 -> 출력 방향으로 이 그래프들 따라 연산을 수행한다.
- 역전파:  
	- 역전파는 출력 -> 입력 방향으로 이 그래프를 따라 미분을 계산한다.

- 알고리즘은 클래스이다.
- sig를 쓴다는 것은 알고리즘을 가져온다는 것이다. 딱 sig만 쓴다.

에포크(epoch)**는 **모델이 전체 학습 데이터를 한 번 모두 학습한 횟수**

#### 신경망
- 제프리힌턴의 순전파와 역전파, 옵티마이저 등이 이뤄지는 공간을 신경망이라고 한다. 
- 신경망은 layer로 되어 있다. 

#### tensorflow
- 면의 움직임을 tensorflow라고 한다.
#### 전파하는 2가지 방법
- 이벤트가 전달되는 순서를 전파라고 한다. 전파의 두 가지 방식은 버블링과 캡쳐링이다.
- 버블링: 밑에서 위로(자식 --> 부모)
- 캡쳐링: 위에서 밑으로(부모 --> 자식)



#### 신경망 각 계층에 연산이 있는데, 신경망에서 wx+b, relu, softmax가 뭐야?
- wx+b: 선형 활성화 함수(가중합 연산): 이것은 옵티마이저를 구하는 공식이다.
- **`x`**: 입력 벡터 (예: 이미지 픽셀, 숫자 등)
    
- **`w`**: 가중치 (weight) — 학습되는 값
    
- **`b`**: 편향 (bias) — 학습되는 값
    
- **결과**: 입력을 선형 변환한 값


ReLU: 비선형 활성화 함수 (Rectified Linear Unit)


#### 직렬 및 병렬 방식
- 선으로 가는 것을 직렬방식이라고 한다.
- 면으로 가는 것을 병렬방식이라고 한다. 면을 그래프라고 한다.
#### 뉴런 네트워크
- 신경망이다. 뉴런의 집합이다.
- 
#### 활성화 함수
- 뉴런이 반응하는 결정하는 함수이다. 
- 뉴런에서 출력값을 변경시키는 함수를 활성화 함수이다. 
- return 뒤에 있는 함수를 의미함
- 예시: 시그모이드 함수(이진분류이다. 예시: 스팸이냐 아니냐.....남자냐 여자냐..), 소프트맥스 함수(예시: 개, 고양이, 냉장고)

#### 노드 안에 세가지 함수(wx+b, relu, softmax)가 있다. 




#### 비활성화 함수



#### 뉴런
- 뉴런 안에 알고리즘이 들어 있고, 다 똑같은 알고리즘이 아니라 하는역할에 따라 알고리즘이 다르다.
#### 파인 튜닝: 
- 몇 가지 뉴런을 선택해서 최적화 시키는 것을 의미한다. 


###### 변수 하나 가지고 따진다. --> linear이다. 그리고 wx+b를 생각해라


1초 후의 변화율을 알고싶을 때, 기울기를 구해야한다. 

뉴런이 엣지를 통해서 가중치와 바이어스(편차)를 준다. 


최적화된 옵티마이저인 것을  예측값이다. -->꼭지점에서 확인할 수 있다.


lr= 학습률이다.


##### 1 에포크는 배치를 전체 한번 도는 것을 의미함. 미니 배치는 여러번 돌려야 1번 포크한다.  
- 배치 : 데이터를 가로로 잘게 쪼갠 것을 의미함.
- 미니 배치: 배치를 더 잘게 쪼갠 것을 의미함.

##### 스팸메일 분류 --> 로지스틱 회귀이다. (스팸이냐 아니냐)
#### 0 에서 1 사이의 확률에 따른 결정 --> 소프트맥스 회귀(선택지의 경우의 수가 많아졌을 때 사용함)

#### 소프트맥스 회귀
- 우리가 아래처럼 원-핫 인코딩을 정해주고, ....

#### 원-핫 인코딩
- 범주형(카테고리형) 데이터를 숫자로 표현하는 대표적인 방법을 의미함.
- 분류 문제에서 정답(label)**을 표현할 때 자주 사용됨
- **하나의 항목만 1, 나머지는 전부 0**으로 표현하는 방식

|클래스 이름|정수 인코딩|원-핫 인코딩|
|---|---|---|
|고양이|0|[**1**, 0, 0]|
|개|1|[0, **1**, 0]|
|토끼|2|[0, 0, **1**]|
- 우리는 위의 원-핫 인코딩을 알려주고, 학습 훈련을 시켜야 한다.
- 총 선택지가 3개였으므로 위 벡터들은 전부 3차원 벡터가 되었다.

##### 하이퍼파라미터
- 보통 사용자가 직접 정해줄 수 있는 변수
- 외부에서 주입되는 것을 의미함.

##### 하이퍼파라미터
- 외부에서 주입되는 링크를 의미함

##### 매개변수: 
- 모델이 학습되는 과정에서 얻어지는 값을 의미함.


#### 지도 학습 vs 비지도 학습
- 라벨의 유무

##### 비지도학습과 강화학습의 차이
- 에이전트의 유무
##### 강화학습: 에이전트가 들어간 학습을 의미함.
- 에이전트: 
	- 에이전트(agent)**는 사람처럼 **주어진 목표를 달성하기 위해 ‘환경을 인식하고’, ‘판단하고’, ‘행동하는’ 자율적인 소프트웨어 또는 시스템**을 말한다.
	- 즉, 스스로 판단하고 행동하는 ai시스템을 의미함. 
	- 에이전트는 api를 통해서 가져온다.
	- 에이전트는 api이다.
	- 에이전트는 여러 개이다. 작업을 분담해서 api를 최대한 비슷한 것을 가져온다.
	- 에이전트는 api이니깐, 엔드포인트 url을 가지고 있다는 것을 알 수 있다.
	- 
##### 결론, 모델 = api
##### MCP
mcp(Model Context Protocol): api 형태로 되어있는 파일을 의미함.
	- model: 파일을 의미함
	- context: 맥락을 의미함
	- api를 주면 모델을 받을 수 있으니까 api가 있으면 모델이 있다. 그냥 url만 주면 모델을 얻을 수 있다.
	- 앞으로 모델은 api이다.
	- 사용자에 맞게 바꿔줄 수 있다! 예를 들어, 단일 ai 에이전트(하나의 만들어진 api, 즉 모델을 의미함)와 외부 환경(여기서 외부환경은 모델을 쓰려고 하는 기관, 업체를 의미함)

로우나 레코드나 같은 말이다. 즉, 타이나틱에서 이름, 나이, 성별, 이런..한 줄을 레코드라고 하고, 머신러닝에서는 샘플이라고 한다.


##### 독립변수와 종속변수

독립변수(x): 독립변수는 여러개이다.
- 결과에 영향을 주는 변수

종속변수(y): 종속변수는 한 개이다.
- 독립변수에 따라 값이 달라지는 변수


차원은 독립변수에 따라 값이 달라진다.


정확도(accuracy): 맞춘 문제 수를 전체 문제 수로 나눈 값을 의미함. 맞춘 문제수가 많을 수록 정확도가 높아진다.


#### 혼동 행렬: 오답 노트이다. 
- 모델의 예측 결과가 얼마나 맞았는지, 어떤 식으로 틀렸는지를 보여주는 표
- ###### 오답이 나왔을 때, 혼동 행렬을 작성해서 정확도를 높인다.
- 정확도가 높지 않을 때, 혼동 행렬을 써야 한다. 계속 훈련을 시켜야 한다.



#### 정확도 vs 정밀도 vs 재현률

- **정확도(Accuracy)**, **정밀도(Precision)**, **재현율(Recall)**은 모두 **분류 모델의 성능을 측정하는 지표**이지만, **의미와 강조하는 포인트가 다릅니다.**
- 정확도
	- 전체 중에서 맞게 예측한 비율을 의미함. 데이터가 균형잡힌 경우, 예측안한 경우에 사용됨.
- 정밀도
	- positive라고 예측한 것 중에 실제로 맞은 비율, 무조건 정답이라고 한 것은 맞아야 한다.
- 재현률
	- 10명이 positive라고 했는데, 실제로는 8명이 나왔고, 나머지 2명에 대해 왜 positive가 안나왔는지 역추론을 해야하는 경우이다.




인공 신경망 - ann

인공 신경망 - 머


퍼셉트론: 인식하는 기계를 의미함.

모델 안에 알고리즘이 있고, 알고리즘은 class이다. 


퍼셉트론: 



뉴런: y =wx+b





- 제프리 힌턴 (Geoffrey Hinton) - 영국  
	-  MLP, 역전파 알고리즘  
		- 역전파 알고리즘 이란?  
			- 모델의 depth가 깊어질수록, 모델의 층이 많아질수록 모델의 가중치의 수는 기하급수적으로 많이 늘어남.
- 얀 르쿤 (Yann LeCun) - 프랑스  
	- CNN(합성곱 신경망) - 이미지와 같은 그리드 형태 데이터 처리에 매우 효과적인 CNN 구조  
					- 컴퓨터 비전 분야에서 엄청난 성능 개선을 이룸.
- 요수아 벤지오(Yoshua Bengio) - 프랑스  
	- RNN & NLP : Word Embeddig과 신경망 기반 언어 모델 연구에 중요한 기여  
	- _GAN_(Generative Adversarial Nets) : AI 그림 생성의 시초  
		- 기계 번역, 챗봇, 텍스트 생성 등 현대 NLP 기술 발전에 지대한 영향
- 앤드루 응(Andrew Ng) - 홍콩  
	-  2012년 유튜브 동영상에서 고양이 얼굴을 스스로 학습하는 신경망 연구는 딥러닝의 가능성을 대중에게 각인시키는 중요한 계기,  **Coursera**

#### 단층 퍼셉트론

![[Pasted image 20250507142932.png]]
#### 다층 퍼셉트론

![[Pasted image 20250507142950.png]]


ann --> 은닉층이 없다. 이건 머신러닝
히든 레이어 --> D라고 한다. 이때, 이건 딥러닝: DNN(은닉층이 여러개 있는 것을 의미함)


시그모이드 함수 --> 이진분류 이다.

```
from fastapi import Body, FastAPI, APIRouter, Request, UploadFile, File

from fastapi.middleware.cors import CORSMiddleware

from fastapi.responses import JSONResponse

from typing import Dict, Any

from contextlib import asynccontextmanager

import os

import logging

import json

from dotenv import load_dotenv

import httpx

  

# ✅ 서브 라우터 임포트

  

from app.domain.model.service_type import ServiceType

from app.domain.model.service_proxy_factory import ServiceProxyFactory

  

# ✅ 로깅 설정

logging.basicConfig(

    level=logging.INFO,

    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',

)

logger = logging.getLogger("gateway_api")

  

# ✅ 환경 변수 로드

load_dotenv()

  

# ✅ 라이프스팬 설정

@asynccontextmanager

async def lifespan(app: FastAPI):

    logger.info("🚀 Gateway API 서비스 시작")

    logger.info(f"서비스 URL 구성:")

    yield

    logger.info("🛑 Gateway API 서비스 종료")

  

# ✅ FastAPI 앱 설정

app = FastAPI(

    title="Gateway API",

    description="Gateway API for kimdonghee.com",

    version="0.1.0",

)

  

# ✅ CORS 설정

app.add_middleware(

    CORSMiddleware,

    allow_origins=["*"],

    allow_credentials=True,

    allow_methods=["*"],

    allow_headers=["*"],

)

  

# ✅ 메인 API 라우터 생성

api_router = APIRouter(prefix="/ai/v1", tags=["Gateway API"])

  

# ✅ 메인 라우터 실행

  

# ✅ GET 프록시

@api_router.get("/{service}/{path:path}", summary="GET 프록시")

async def proxy_get(

    service: ServiceType,

    path: str,

    request: Request

):

    factory = ServiceProxyFactory(service_type=service)

    response = await factory.request(

        method="GET",

        path=path,

        headers=dict(request.headers)

    )

    return JSONResponse(content=response.json(), status_code=response.status_code)

  

# ✅ POST 프록시 (💥 수정됨)

@api_router.post("/{service}/{path:path}", summary="POST 프록시")

async def proxy_post(

    service: ServiceType,

    path: str,

    request: Request

):

    logger.info(f"🌈 Received POST request for service: {service}, path: {path}")

    factory = ServiceProxyFactory(service_type=service)

  

    content_type = request.headers.get("content-type", "")

    headers = dict(request.headers)

  

    # ✅ 파일 업로드 요청인지 확인

    if content_type.startswith("multipart/form-data"):

        form = await request.form()

        form_data = dict(form)

  

        # 파일 처리

        file_field = form_data.get("file")

        if not file_field:

            return JSONResponse(

                content={"detail": "No file field found in form data."},

                status_code=422

            )

  

        # multipart/form-data 처리를 위한 클라이언트 사용

        async with httpx.AsyncClient() as client:

            files = {

                "file": (file_field.filename, await file_field.read(), file_field.content_type)

            }

            response = await client.post(

                url=f"{factory.base_url}/{service.value}/{path}",

                files=files,

                headers={"accept": "application/json"}

            )

            try:

                return JSONResponse(content=response.json(), status_code=response.status_code)

            except json.JSONDecodeError:

                return JSONResponse(

                    content={"detail": "⚠️ Invalid JSON response from service"},

                    status_code=500

                )

    else:

        # ✅ 일반 JSON 요청 처리

        body = await request.body()

        response = await factory.request(

            method="POST",

            path=path,

            headers=headers,

            body=body

        )

        if response.status_code >= 200 and response.status_code < 300:

            try:

                return JSONResponse(content=response.json(), status_code=response.status_code)

            except json.JSONDecodeError:

                return JSONResponse(

                    content={"detail": "⚠️ Invalid JSON response from service"},

                    status_code=500

                )

        else:

            return JSONResponse(

                content={"detail": f"Service error: {response.text}"},

                status_code=response.status_code

            )

  

# ✅ PUT 프록시

@api_router.put("/{service}/{path:path}", summary="PUT 프록시")

async def proxy_put(

    service: ServiceType,

    path: str,

    request: Request

):

    factory = ServiceProxyFactory(service_type=service)

    response = await factory.request(

        method="PUT",

        path=path,

        headers=dict(request.headers),

        body=await request.body()

    )

    return JSONResponse(content=response.json(), status_code=response.status_code)

  

# ✅ DELETE 프록시

@api_router.delete("/{service}/{path:path}", summary="DELETE 프록시")

async def proxy_delete(

    service: ServiceType,

    path: str,

    request: Request

):

    factory = ServiceProxyFactory(service_type=service)

    response = await factory.request(

        method="DELETE",

        path=path,

        headers=dict(request.headers),

        body=await request.body()

    )

    return JSONResponse(content=response.json(), status_code=response.status_code)

  

# ✅ PATCH 프록시

@api_router.patch("/{service}/{path:path}", summary="PATCH 프록시")

async def proxy_patch(

    service: ServiceType,

    path: str,

    request: Request

):

    factory = ServiceProxyFactory(service_type=service)

    response = await factory.request(

        method="PATCH",

        path=path,

        headers=dict(request.headers),

        body=await request.body()

    )

    return JSONResponse(content=response.json(), status_code=response.status_code)

  

# ✅ 메인 라우터 등록

app.include_router(api_router)

  

# ✅ 서버 실행

if __name__ == "__main__":

    import uvicorn

    port = int(os.getenv("PORT", 9000))  # 기본 9000

    uvicorn.run("app.main:app", host="0.0.0.0", port=port, reload=True)
```
