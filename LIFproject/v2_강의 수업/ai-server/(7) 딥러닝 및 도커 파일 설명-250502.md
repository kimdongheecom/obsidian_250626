
#### 도커 개념
- 도커는 고래이다. 
- **컨테이너의 집합**이다.
- 도커 안에는 컨테이너가 들어있다.
- 마이크로서비스를 모아나서 도커에 올려논다.
#### 객체
- 기능과 속성의 집합이다.

#### 폴더와 파일의 차이점
- 확장자가 있냐 없냐.

#### State:
- 본질이 바뀌지 않음.
- 변화가 끝난 시점을  의미함.
- 대체될 뿐이다.
#### 롤 백
- **에러가 나기 전의 작업으로 되돌리는 것**을 의미함.

#### CICD
- 컨테이너로 즉각 즉각 저장되는 것
- 예시) 도커 허브
#### 도커 허브
- **도커 이미지들을 저장하고 공유하는 “클라우드 저장소”입니다.**  GitHub이 소스코드를 저장하고 공유하는 곳이라면,  Docker Hub는 **도커 이미지(앱 실행 환경)를 저장하는 곳**입니다.

###### 백엔드 상태 관리자: 도커
###### 프론트엔드 상태 관리자: 리덕스

##### app과 dockerfile에 대한 설명
- app - 상태가 변하는 공간
- dockerfile - 이미지를 찍는 공간(상태를 찍는 공간)



#### Dockerfile에 대한 설명

![[Pasted image 20250502104311.png]]

로컬에 있는 개발환경과 도커에 있는 개발환경을 같게 만들어줄려고 한다. (아래 이미지....)


상태 관리자와 상태가 변하는 공간

파일은 기능이 존재한다.
폴더는 공간이 존재한다.

도커 파일은 앱의 상태를 관리하는 관리자이다. 즉, 객체이다. 리콰이어먼트를 app에다가 복사해준다. 
작업장: app이다.


```
FROM python:3.12.7-slim (도커의 부하직원이 python)

  

WORKDIR /app(도커 파일의 작업장을 의미함)

COPY requirements.txt .(도커파일이 app에 이 파일을 복사한다.)

RUN pip install --no-cache-dir -r requirements.txt

  

# ✅ 누락된 경우 대비: xlrd 명시적 설치

RUN pip install --no-cache-dir xlrd>=2.0.1

pip가 라이브러리를 설치하는 python의 부하직원 놈을 의미함

  

COPY . .

  

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "9002", "--reload"]
```

계급
- 도커 > python > pip

COPY . .
- 브라우저에서 찍히는 최종 이미지가 아니라, 우리가 빌드했을 때, 이미지를 복사하겠다.

EXPOSE 9002
- 찍었던 이미지를 9002번 포트에 보내줄꺼를 의미함.

![[Pasted image 20250502111109.png]]
위에 CMD는 파이썬이 uvicorn에게 메세지를 보내는 것이다.
uvicorn(도커 없을 때  로컬에서 돌릴 수 있도록 하는 것)이 app에 들어가서 localhost인지, 브라우저인지 모르는 것이다. 

- uvicorn: 부하직원이
- app.main:app: 작업장의 주소를 말해줌
- --host: 
- 0.0.0.0:
- --port:
- reload: 조금 고칠 때마다 자동으로 실행하게 해주는 것



DokerFile: 라이브러리 환경만 만들고 있다.


환경조건을 가지고, docker 컨테이너를 만든다. 


docker-compose.yml: 컨테이너 만들고 있다. 


- DokerFile: 내부 속성값을 정의한다.
- docker-compose.yml: 컨테이너를 빌드하고, 저장하고, 연결하늑 것을 의미함


#### 딥러닝


엔드 투 엔드(End-to-End, E2E) --> 시작부터 끝까지 전 과정을 하나로 연결해서 처리한다


#### 라이브러리 vs 프레임워크 vs 플랫폼
- 플랫폼은 라이브러리와 프레임워크 다 포함하는 환경을 의미함

##### 차원
0차원: 스칼라
1차원: 벡터
2차원: 매트릭스
3차원 이상: 텐서




#### Google Colab
- Google에서 제공하는 **클라우드 기반 파이썬 실행 환경**
- 단점: 휘발성이다. 저장을 할 수가 없다.



#### CPU vs GPU
- CPU - 직렬적으로 일을 처리하는데 빠르다.
- GPU - 병렬적으로 일을 처리하는데 빠르다. 병렬은 요청사항이 한꺼번에 간다. 요청사항의 예시는.....사진으로 찍어서 데이터를 가져오는 방식을 의미함.그니까 한꺼번에 처리가능한거다.


#### 벡터 디비(ai-서버에서 사용)와 일반 디비(api-server에서 사용)
- ai에서는 벡터 디비를 사용한다. 요리사 10명이 한그릇을 사용하는 느낌,,,,,,,,한꺼번에 다 하는것, 데이터 양이 많을 때 사용한다. 이미지, 영상, 음성의 데이터를 처리할 때 사용한다.
- 일반 디비는 인서트가 하나일때 사용한다. 데이터 양이 적을 때 사용한다.



기본 함수에 데코레이터 패턴을 걸면 인공지능 함수가 된다.


#### 체크 포인트(체크 포인트가 쌓이면 예측 알고리즘이다.이게 객체 상태이니까 이걸 옵티 마이저라고 한다.)
- AI 모델이 학습 중간에 저장한 상태 (가중치, 옵티마이저 등)**을 말합니다.  나중에 이어서 학습하거나, 예측에 활용할 수 있어요.
- 상태를 준다 = 가중치를 둔다.
- 체크포인트는 파일이다. 다른 파일에 이식이 가능하다. 계속 옮겨질 수 있다. 체크 포인트가 계속 과거의 이력을 가지고 있다. 가중치는 상태를 누적된 상태를 의미한다. 계속 누적될 수 있다.
- 옵티마이저는 가중치가 끝나버린 녀석을 옵티마이저라고 한다. 옵티마이저는 객체이다. 옵티마이저는 가중치가 이미 정해진 상태이다. 

```
model.save_weights("checkpoint.ckpt")  # 저장
model.load_weights("checkpoint.ckpt")  # 불러오기

```

#### 옵티마이저(예측 알고리즘)
- 딥러닝에서 모델이 더 정확해지도록 “가중치를 조정”해주는 알고리즘을 의미함

#### 얼굴 모자이크를 자동처리 하는 것

#### 목적: 얼굴 인식 프로그램 만들기
1. 파일 업로드 하는 방법을 알아야한다.


###### with :작업이 끝나면 자동으로 이 파일을 닫아주는 역할을 한다. 작업이 완료 될따까지 기다려주라는 것을 의미함...?이미지, 동영상들을 뽑아낼때, with 절을 사용한다. 그리고 buffer는 차원이 1차원까지 쪼개지고 인덱싱할 때, 즉 데이터를 뽑아낼 때 물을 채워 가지고, 같이 있어야 한다. 그래야 파일 손상이 없다. buffer는 파일 손상이 없게 데이터를 완제품으로 뽑아낼 수 있게 완충제 역할을 한다.



컴퓨터가 이미지를 숫자로 인식해서 인코딩


차원이 이동을 해서 이미지가 전달된다? 

데이터에 대한 회손없이 큰장에 다 데이터를 붙인다. 그럼 차원이 줄어든다. 차원이 감소되도 데이터는 다 달라붙는다. 

사진도 선처럼 다 자른다. 그럼 1차원이 된다. 1차원 이상에서 0차원으로 더이상 쪼갤 수가 없다. 1차원이 마지막이다. 1차원은 벡터 구조이다. 

긴 벡터 구조에서 인덱스 값을 저장한다. 즉, 1차원에서 다 쪼개진다. 모든 데이터들은 뽑아낼 때 차원을 1차원까지 다 쪼개서 뽑아낸다.  버퍼는 