public - 공개할 수 있는 부분(지금은 public만 할 것이다.)
private- 삼정에게 공개안하고 싶은 부분


##### v1-프로젝트 프롬프팅
1. msa구조로 작성할꺼야. 각 마이크로서비스는 비동기 fastapi로 구현하고, 각각의 도커파일을 가질꺼야. docker-compose.yml로 연결할꺼야. 그리고 db는 postgresql을 하나로 공유할꺼야. 최종적으로 배포는 railway를 할 것이고, 특별히 private 인 config서버는 두지 않을꺼야. 너가 생성해야할 마이크로 서비스는 다음과 같아. gateway-service 8080, finance-service 8000,esg-service8002, stock-service 8001를 작성해줘.  

	각각의 마이크로 서비스 내부 구조는 아래와 같아.  
	  
	gateway-service/  
	├── app/  
	│ ├── __init__.py  
	│ ├── main.py  
	├── .env  
	├── requirements.txt  
	├── Dockerfile  
	└── README.md  
	이 구조로 만들어주고 docker-compose.yml을 통해 fastapi를 실행할 수 있도록 해줘. 도커file에서 파이썬버전은 3.12.7이고 reload옵션을 추가해줬으면 해. 그다음에 port는 8080으로 해줘. 도메인 주소는 www.kimdonghee.com 이야. APIRouter 생성자의 prefix는 /e로 하고, async방식으로 작동되게 해줘. requirements.txt에 기본적으로 등록된 라이브러리는 다음과 같다.  
	fastapi uvicorn asyncpg sqlalchemy python-dotenv pytz email_validator passlib[bcrypt]==1.7.4 shortuuid==1.0.13 python-jose[cryptography] redis==5.2.1 그리고 최종적으로 swagger에서 ("/")하면 Welcome Message가 뜰 수 있게 해줘. app.include_router(api_router)처럼 app이 api_router를 포함하게 해줘. 그리고 __init__.py에는 어떠한 코딩작업도 하지마.


2. (아래 사진처럼 폴더 및 파일 구조를 만들어짐)
	   ![[Pasted image 20250422172717.png]]
3. (아래 사진처럼 폴더 및 파일 구조를 만들기)
	 ![[Pasted image 20250422172747.png]]


##### 여기서 중요한 사실!
- gateway-service에 있는 router가 메인 라우터가 된다.
- 그리고 각각의 esg-service, stock-service, finance-service에 있는 main.py는 서브라우터가 된다. 


##### 백엔드와 프론트엔드 연동하는 방법

	백엔드 파일 구조를 완성시킨 후, 프론트엔드와 연동을 시켜야 한다. axios만 맞추면 된다.
	
	프론트에서 https 요청을 하면 axios를 보내서, 백엔드 라우터랑 연결을 시켜야 한다. 
	
	사이트에 들어가서 로그인을 한 후, 아래 이미지를 보면 콘솔창이 있는데, 콘솔창의 맨 왼쪽에 화살표표시가 있다. 거기를 눌러서 확인을 해봐야 한다.
	
	계속 함수가 연결되어 있는 부분을 찾아서 axios를 확인하기. 


![[Pasted image 20250422173944.png]]


#### table 만들기(정규화 테이블 설계) -ddl, dql , 추가로 3nf(제 3규화 정규화 된 txt) 만들기
- 테이블 리팩토링한 것을 정규화라고 한다. 
- 테이블 안에 너무 많아서 리팩토링이 필요하다.
- normal form(정규화 패턴) - 총 7개의 정규화가 있다. (제1~6 정규화, 제BCNF)
- 교과서적으로 제 6정규화가 되었으면 정규화라고 하지만, 비공식적으로 제 3정규화가 되었으면 정규화가 되었다. 이걸 역정규화라고 함(제 3정규화는 부모, 자식, 교차엔티티로 리팩토링한 것을 의미함)
- table 명을 financials로 정함
- 커서한테 질문할 경우, table 명을 financials로 정함. 그리고 이것을 정규화하고 싶은데, 3정규화까지만 해줘. 분리된 테이블은 부모-자식 관계 또는 교차엔티티 까지만 작성해줘.
- 테이블 명을 만들때, _ 또는 ratio_

###### 총 5개 테이블 완성
![[Pasted image 20250423105658.png]]


##### 스레드 구현

1. entity 코드 구현
	###### **프롬프팅**
	finance-service 폴더 아래에 있는 domain 폴더 아래에 있는 models 폴더 아래에 있는 entity 폴더에 파일을 생성해주고, 그 파일에 ddl.sql에 있는 테이블 명에다가 접미사로 Entity로 붙여서 예를 들면 CompanyEntity 이렇게. 컬럼은 다음에 열거하는 코드를 참조해서 생성해줘. 그리고 __init__.py에는 어떠한 코드도 작성하지마.  
	
							           List of relations
					
					 Schema |    Name    | Type  |  Owner  
					
					--------+------------+-------+----------
					
					 public | companies  | table | postgres
					
					 public | financials | table | postgres
					
					 public | metrics    | table | postgres
					
					 public | reports    | table | postgres
					
					 public | statements | table | postgres
	  
	from datetime import UTC, datetime  
	from sqlalchemy import TIMESTAMP, Column, Integer, String, DateTime, func  
	from sqlalchemy.ext.declarative import declarative_base  
	  
	Base = declarative_base()  
	  
	class UserEntity(Base):  
	__tablename__ = "user"  
	  
	user_id = Column(String, primary_key=True, doc="개인정보동의내역id")  
	personal_id = Column(String, nullable=True)  
	survey_id = Column(String, nullable=True)  
	member_number = Column(String, nullable=True)  
	role = Column(String, nullable=True)  
	fullname = Column(String, nullable=True)  
	nickname = Column(String, nullable=True)  
	gender = Column(String, nullable=True)  
	birth_date = Column(String, nullable=True)  
	email = Column(String, unique=True, index=True, nullable=False)  
	phone = Column(String, nullable=True)  
	street = Column(String, nullable=True)  
	suburb = Column(String, nullable=True)  
	postcode = Column(String, nullable=True)  
	profile_image = Column(String, nullable=True)  
	password = Column(String, nullable=False)  
	  
	  
	  `created_at`은 DB에서 자동 생성  
	created_at = Column(TIMESTAMP, nullable=False, server_default=func.now(), doc="생성 날짜")  
	  
	`updated_at`은 FastAPI에서 직접 갱신  
	updated_at = Column(TIMESTAMP, nullable=False, doc="수정 날짜")  
	  
	__mapper_args__ = {  
	"polymorphic_identity": "user",  
	"polymorphic_on": role # 역할(role)에 따라 WorkerEntity, SupervisorEntity로 매핑  
	}  
	  
	def update_timestamp(self):  
	"""FastAPI에서 `updated_at`을 직접 갱신하는 메서드"""  
	self.updated_at = datetime.now(UTC)


###### entity 코드 구현 설명
이제 모든 Entity 클래스가 생성되었습니다. DDL에 있는 모든 테이블에 대한 Entity 클래스를 만들었습니다:

	1. CompanyEntity: companies 테이블을 매핑하는 엔티티
	
	2. FinancialEntity: financials 테이블을 매핑하는 엔티티
	
	3. MetricEntity: metrics 테이블을 매핑하는 엔티티
	
	4. ReportEntity: reports 테이블을 매핑하는 엔티티
	
	5. StatementEntity: statements 테이블을 매핑하는 엔티티

각 엔티티는 다음 특징을 가지고 있습니다:

		- 적절한 테이블 이름 매핑
		
		- 테이블의 주요 컬럼 정의
		
		- created_at, updated_at 타임스탬프 필드
		
		- 업데이트 타임스탬프 메서드
		
		- 테이블 간 관계 설정(relationship)

이 엔티티들은 SQLAlchemy ORM을 통해 테이블과 매핑되며, finance-service에서 데이터베이스 작업을 수행할 때 사용할 수 있습니다.


2. schema 코드 구현

  
	finance-service 폴더 아래에 있는 domain 폴더 아래에 있는 models 폴더 아래에 있는 schema 폴더에 파일을 생성해주고, 그 파일에 ddl.sql에 있는 테이블 명에다가 접미사로 Schema로 붙여서 예를 들면 CompanySchema 이렇게. 컬럼은 다음에 열거하는 코드를 참조해서 생성해줘. 그리고 __init__.py에는 어떠한 코드도 작성하지마.  

										   List of relations
								
								 Schema |    Name    | Type  |  Owner  
								
								--------+------------+-------+----------
								
								 public | companies  | table | postgres
								
								 public | financials | table | postgres
								
								 public | metrics    | table | postgres
								
								 public | reports    | table | postgres
								
								 public | statements | table | postgres
	  
	from pydantic import BaseModel, EmailStr  
	from datetime import date, datetime  
	class UserSchema(BaseModel):  
	user_id: str | None = None  
	personal_id: str | None = None  
	survey_id: str | None = None  
	member_number: str | None = None  
	roles: str | None = None  
	fullname: str | None = None  
	nickname: str | None = None  
	gender: str | None = None  
	birth_date: date | None = None # :흰색_확인_표시: 날짜 타입  
	email: EmailStr  
	phone: str | None = None  
	street: str | None = None  
	suburb: str | None = None  
	postcode: str | None = None  
	profile_image: str | None = None  
	password: str  
	created_at: datetime | None = None # :흰색_확인_표시: 생성 및 수정일은 datetime 사용  
	updated_at: datetime | None = None  
	model_config = {  
	"from_attributes": True # :흰색_확인_표시: Pydantic v2 스타일 적용  
	}


###### schema 코드 구현 설명
모든 Schema 클래스가 성공적으로 생성되었습니다. DDL.sql에 있는 각 테이블에 대해 Pydantic Schema 클래스를 만들었으며, 각 클래스는 기본 Schema, Create Schema, Update Schema로 구분하여 작성했습니다:

	1. CompanySchema, CompanyCreateSchema, CompanyUpdateSchema - companies 테이블 매핑
	
	2. FinancialSchema, FinancialCreateSchema, FinancialUpdateSchema - financials 테이블 매핑
	
	3. MetricSchema, MetricCreateSchema, MetricUpdateSchema - metrics 테이블 매핑
	
	4. ReportSchema, ReportCreateSchema, ReportUpdateSchema - reports 테이블 매핑
	
	5. StatementSchema, StatementCreateSchema, StatementUpdateSchema - statements 테이블 매핑

각 Schema 클래스는 다음과 같은 특징을 가지고 있습니다:

		- Pydantic BaseModel을 상속받음
		
		- 해당 필드의 타입과 기본값 정의
		
		- Create와 Update 동작에 필요한 별도 스키마 클래스 제공
		
		- model_config = {"from_attributes": True} 설정 (Pydantic v2 스타일)

이 스키마들은 API에서 요청 및 응답 모델로 사용할 수 있으며, SQLAlchemy 모델과 함께 사용하여 데이터 검증 및 직렬화/역직렬화를 처리할 수 있습니다.

3. factory 코드 구현

	finance-service 폴더 아래에 있는 domain 폴더 아래에 있는 factory 폴더 아래에 파일을 생성해주고, 그 파일에 ddl.sql에 있는 테이블 명에다가 접미사로 Factory로 붙여서 예를 들면 CompanyFactory 이렇게. 컬럼은 다음에 열거하는 코드를 참조해서 생성해줘. 그리고 __init__.py에는 어떠한 코드도 작성하지마.


							           List of relations
							
							 Schema |    Name    | Type  |  Owner  
							
							--------+------------+-------+----------
							
							 public | companies  | table | postgres
							
							 public | financials | table | postgres
							
							 public | metrics    | table | postgres
							
							 public | reports    | table | postgres
							
							 public | statements | table | postgres



라우터 → 컨트롤러 → 팩토리 → 유스케이스 → 서비스



