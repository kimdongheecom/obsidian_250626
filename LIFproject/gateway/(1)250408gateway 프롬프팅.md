업데이트:250416
업데이트:250422
### -- users 폴더 --
**커서 질문,**

gateway/  
├── app/  
│ ├── __init__.py  
│ ├── main.py  ← FastAPI 진입점 
├── .env  
├── requirements.txt  
├── Dockerfile  
├── docker-compose.yml  
└── README.md  
  
이 구조로 만들어주고 docker-compose.yml을 통해 fastapi를 실행할 수 있도록 해줘. 도커file에서 파이썬버전은 3.12.7이고 reload옵션을 추가해줬으면 해. 그다음에 port는 8080으로 해줘. 도메인 주소는 www.jinmini.com 이야. APIRouter 생성자의 prefix는 /e로 하고, async방식으로 작동되게 해줘. requirements.txt에 기본적으로 등록된 라이브러리는 다음과 같다. 
fastapi uvicorn asyncpg sqlalchemy python-dotenv pytz email_validator passlib[bcrypt]==1.7.4 shortuuid==1.0.13 python-jose[cryptography] redis==5.2.1 그리고 최종적으로 swagger에서 ("/")하면 Welcome Message가 뜰 수 있게 해줘. app.include_router(api_router)처럼 app이 api_router를 포함하게 해줘. 그리고 __init__.py에는 어떠한 코딩작업도 하지마. 

포트번호, 도메인 주소, prefix을 알려줘야 함.

**커서 질문,**
main.py에서 hello world를 실행하게 해줘.


**커서 질문,**
pip install fastapi uvicorn 이것 대신에  requirements.txt로 하고, 실행을 Dockerfile, docker-compose up -d로 하도록 해줘.


**콘솔 창에 명령어 추가**
그리고 처음 실행하는거니까, **docker-compose up --build -d** 명령어를 해줘야 한다. 


**콘솔 창에 명령어 추가**
그리고 컨테이너가 없을 경우에는 docker-compose up -d를 해주면 된다. 



![[Pasted image 20250408150134.png]]

이 다음 단계는 250417 파일에 보면 된다.
#### gateway 폴더 생성 및 sweagger에서 띄우기 과정!!!!!

**model 파일 만들기**

app/domain/gateway/models 폴더에 gateway_model.py 파일을 생성했습니다.

기본 코드에서 다음과 같이 확장했습니다:

1. Optional 타입과 datetime 모듈을 가져왔습니다

2. OAuthEntity 모델에 다음 필드를 추가했습니다:

	- refresh_token: 선택적인 리프레시 토큰 필드
	
	- expires_at: 토큰 만료 시간
	
	- created_at: 엔티티 생성 시간 (기본값으로 현재 시간 설정)

3.  Config 클래스를 추가하여 ORM과 통합할 수 있도록 from_attributes 옵션을 설정했습니다

이 모델은 여러 OAuth 제공자로부터 받은 인증 정보를 저장하는 데 사용할 수 있습니다.


**schema 파일 만들기**

1. OAuthSchema 클래스:

	- provider와 code 필드는 그대로 유지
	
	- redirect_uri 필드 추가 (선택적)
	
	- Config 클래스를 통해 JSON 스키마 예제 추가하여 API 문서 개선

2. OAuthResponseSchema 클래스 추가:

	- access_token: OAuth 인증 결과로 받은 액세스 토큰
	
	- token_type: 토큰 타입 (기본값: "Bearer")
	
	- expires_in: 토큰 만료 시간 (초 단위)
	
	- refresh_token: 리프레시 토큰 (선택적)
	
	- scope: 토큰의 권한 범위 (선택적)
	
	- created_at: 토큰 생성 시간 (현재 시간으로 자동 설정)

이 스키마들은 OAuth 인증 과정에서 요청과 응답 데이터를 검증하고 직렬화하는 데 사용할 수 있습니다.


**repository 파일 만들기**

OAuthRepository 클래스에 실제 데이터베이스 연동 기능을 구현했습니다. 주요 구현 내용은 다음과 같습니다:

1. 데이터베이스 연결 관리:

	- asyncpg 라이브러리를 사용한 PostgreSQL 연결 풀 관리
	
	- 환경 변수에서 데이터베이스 연결 정보 가져오기
	
	- 연결 획득 및 해제를 위한 헬퍼 메서드

2. 테이블 초기화:

	- init_table() 메서드를 통해 필요한 테이블을 생성

3. CRUD 작업 구현:

	- save_oauth(): OAuth 정보 저장 및 업데이트
	
	- find_oauth_by_id(): ID로 OAuth 정보 조회
	
	- find_oauth_by_provider(): 제공자별 OAuth 정보 조회
	
	- delete_oauth(): OAuth 정보 삭제

4. 예외 처리:

	- 모든 데이터베이스 작업에 예외 처리 추가
	
	- 오류 로깅

5. 메모리 캐시:

	- 데이터베이스 연결이 없는 개발 환경을 위한 메모리 저장소 구현

또한, .env 파일에 데이터베이스 연결 정보를 추가했습니다. 이제 데이터베이스에 연결하여 OAuth 정보를 저장하고 조회할 수 있습니다.

**service 파일 구현하기**

app/domain/gateway/services 폴더에 gateway_service.py 파일을 생성하고 OAuthService 클래스를 구현했습니다. 이 서비스는 요청한 코드를 기반으로 확장되었으며 다음과 같은 기능을 제공합니다:

1. 초기화 및 설정:

	- 레포지토리 초기화 및 DB 테이블 생성
	
	- 다양한 OAuth 제공자(Google, Facebook, GitHub) 지원

2. OAuth 핵심 기능:

	- create_oauth: 인증 코드를 토큰으로 교환하고 저장
	
	- get_oauth_by_id, get_oauth_by_provider: 저장된 OAuth 정보 조회
	
	- refresh_oauth_token: 만료된 토큰 갱신
	
	- delete_oauth: OAuth 정보 삭제

3. 외부 서비스 연동:

	- _exchange_code_for_token: 인증 코드로 토큰 요청
	
	- _refresh_token: 리프레시 토큰으로 새 토큰 요청
	
	- _get_provider_config: 제공자별 설정 정보 가져오기

4. 보안 및 에러 처리:

	- 예외 처리 및 로깅
	
	- 환경 변수를 통한 민감 정보 관리

또한 .env 파일에 OAuth 클라이언트 정보를 추가했습니다. 이제 사용자는 실제 사용하는 OAuth 클라이언트 ID와 시크릿으로 이 값들을 업데이트해야 합니다.

이 서비스를 통해 다양한 OAuth 제공자를 통합하여 인증할 수 있으며, 토큰 관리와 갱신도 자동으로 처리할 수 있습니다.

**controller 파일 구현**
gateway_controller.py 파일을 생성하여 요청하신 코드를 구현했습니다. 이 컨트롤러는 다음과 같은 OAuth 관련 API 엔드포인트를 제공합니다:

1. 애플리케이션 시작 시 OAuth 테이블 초기화 기능

2. ID로 OAuth 정보 조회 (GET /oauth/{oauth_id})

3. 제공자별 OAuth 정보 조회 (GET /oauth?provider={provider})

4. OAuth 인증 정보 생성 (POST /oauth)

5. OAuth 토큰 갱신 (POST /oauth/{oauth_id}/refresh)

6. OAuth 정보 삭제 (DELETE /oauth/{oauth_id})

이제 이 라우터를 main.py에 등록하면 해당 경로로 API를 사용할 수 있게 됩니다. main.py 파일을 수정하시려면 다음과 같이 변경해주세요:

#### access_token과 refresh_token을 발급받고, sweagger에서 토큰이 찍히면 성공(목표)!!!!!

**커서 질문, (아래 사진을 첨부하면서) gateway가 swagger에 도달한 상태야. 지금 나는 oauth로 구현하려고 해. jose로 토큰을 관리할거야. 임시로 더미키를 가지고, sweagger에서 테스트 하려고 할 때, 뭘 해야할까? 단계적으로 알려줘.**

![[Pasted image 20250416180733.png]]
위의 단계는 다음 장(구글계정, 네이버 계정, 카카오 계정 연결-250417)에 작성되어 있음...



**커서 질문, 더미 토큰을 집어넣어서 sweagger에서 로그인 테스트 하려고, api 폴더 아래에 tokens_router.py 파일을 만들고, domain 폴더 아래에 있는 gateway에 token_controller.py, token_model.py, token_repository.py, token_schema.py, token_service.py 파일을 만들었어. 난 먼저, @token_schema.py 여기에 아래 코드를 내 코드에 맞춰서 구현해줘. 코드는 최대한 간단하게 해줘. 그리고 토큰은 jose가 관리하도록 해줘. 그리고 api밑에 있는 token_router.py가 있으니까 token_router.py 파일을 새로 생성하지 말고, @tokens_router.py 여기에 연결시켜. 


#### 흐름 순서가 아래 처럼 된다.

1. token_scema.py 코드 구현
2. token_model.py 코드 구현
3. token_repository.py 코드 구현
4. token_service.py 코드 구현
5. token_controller.py 코드 구현
6. token_router.py에 연결 시키기(연결시킬 때, token_controller.py와 token_schema.py를 임포트 해야함.)

#### 구현된 파일 요약

1. 토큰 스키마(app/domain/gateway/schemas/token_schema.py):

	- TokenSchema: 클라이언트에서 받은 토큰을 검증하는 간단한 스키마
	
	- TokenResponseSchema: 토큰 발급 응답 스키마
	
	- TokenVerifyResponseSchema: 토큰 검증 결과 스키마
	

2.  토큰 모델(app/domain/gateway/models/token_model.py):

	- 토큰 정보를 저장하는 간단한 모델


 3. 토큰 저장소(app/domain/gateway/repositories/token_repository.py):

	- 메모리 기반의 간단한 토큰 저장소


4. 토큰 서비스(app/domain/gateway/services/token_service.py):

	- Jose 라이브러리를 사용한 JWT 토큰 생성 및 검증
	
	- 더미 토큰 생성 기능 포함



5. 토큰 컨트롤러(app/domain/gateway/controllers/token_controller.py):

	- 서비스를 호출하고 예외 처리


6. 기존 토큰 라우터 확장(app/api/gateway/tokens_router.py):

	- 기존 라우터에 토큰 생성, 검증, 폐기, 더미 토큰 생성 기능 추가



이제 다음 엔드포인트를 통해 토큰 기능을 사용할 수 있습니다:

- /tokens/create - 새 토큰 생성

- /tokens/verify - 토큰 검증

- /tokens/revoke - 토큰 폐기

- /tokens/dummy - 테스트용 더미 토큰 생성


#### 목표
그리고 더미 데이터를 사용자가 sweagger에 입력했을 때, 사용자가 입력한 더미 데이터 값이 access_token과 일치해야 하고, 그 값은 콘솔 창에 띄어야 한다. 스웨거는 입력 창이고, 스웨거에 입력을 했을 때, 만약 콘솔 창에 그 값이 띄어지면 도커 컨테이너에 들어온 것을 의미한다. 

###### 목표 요약

- Swagger에서 ** body parameter로 자유롭게 문자열 입력**
    
- FastAPI에서 해당 값을 **받아서 콘솔에 출력**
    
- Swagger 응답은 간단한 메시지만 리턴해도 OK





















### gateway 폴더 생성 및 auth 폴더 연결 before 과정 
#### 이 과정을 통해 F12를 눌렀을 때, 브라우저 콘솔창에 access_token과 refresh_token 띄우기

#### ("FastAPI 기반 Gateway – User Service 프록시 연동 완료)


**쳇 지피티 질문** (gateway 폴더)
![[Pasted image 20250408154809.png]]

**위에서 현재 msa를 계속 작업 중이야. 이미지처럼 gateway에서 auth로 연결하는 서비스 디스커버리를 gateway에 추가하고 싶어. "/api/users"를 swagger에서 실행하면 Welcome 메시지를 보게하고 싶어.**



**커서 질문,** (gateway 폴더)
**@main.py(gateway(꺼의 메인라우터이다.... 이 괄호 빼고 커서에 질문하기.) 여기에 GATEWAY 서비스: AUTH로 프록시 요청 보내기를 구현해줘.**


**커서 질문,** (gateway 폴더)
**'AUTH_SERVICE_URL = os.getenv("AUTH_SERVICE_URL", "http://localhost:8001")' 부분을 .env로 옮겨주고, main.py에서는 삭제해줘.** 



**커서 질문,   (gateway 폴더)**
**@docker-compose.yml 에 volumes 추가해줘.**


**커서 질문, (auth 폴더)**

그리고, gateway에서 auth를 연결할 때, 충돌이 날 수 있으니까 auth 폴더에서 docker-compose,yml을 삭제해야함.


그 이후.....


## 🚀 3. 배포 순서 정리

| 순서  | 작업 내용                                                 |
| --- | ----------------------------------------------------- |
| 1.  | `user-service`, `board-service` 등을 **FastAPI로 분리 개발** |
| 2.  | 각각을 **Dockerize**하고 Railway에 개별 배포                    |
| 3.  | **gateway 서비스**를 FastAPI로 만들어 Dockerize & Railway에 배포 |
| 4.  | `.env` 파일에 서비스 주소 넣기                                  |
| 5.  | Vercel의 Next.js 프론트에서 gateway 주소로 통신하게 구성             |
| 6.  | 모든 서비스는 **같은 PostgreSQL DB 인스턴스**를 공유                 |
## 🔧 기술 스택 요약

|항목|사용 기술|
|---|---|
|Backend Gateway|FastAPI + httpx (Proxy 역할)|
|Microservices|FastAPI + SQLAlchemy (혹은 Alchemy 2.0)|
|DB|PostgreSQL (Railway 단일 인스턴스)|
|Frontend|Next.js 15 (Vercel에 배포)|
|배포|Docker + Railway (서비스별 프로젝트)|
|CI/CD|GitHub Actions (선택)|


#### 여기서부터 3번부터 주목! 우린 지금까지 2번까지 했음!
(추가 배경 설명... 그리고 [https://chatgpt.com/share/67f4a244-92fc-8011-bba4-b5fbacc7285c](https://chatgpt.com/share/67f4a244-92fc-8011-bba4-b5fbacc7285c)링크를 참조하면 배포 순서가 나오는데, 위의 배포 순서에서 나는 1,2 단계를 완성했고, 3단계 gateway 서비스를 fastAPI로 만들어 Dockerize & Railway에 배포를 하도록 이 부분만 알려줘. 일단 nextJS에서 /api/user/login으로 요청하면 gateway에 api를 지나는 것을 print로 확인시켜줘.)

**답변!**

좋습니다! 현재 MSA 구조에서 `**GATEWAY**` 서비스에서 `**AUTH**` 서비스로 **경로를 프록시(연결)** 하여 `/api/users` 호출 시 AUTH에서 응답하는 구조를 만들고 싶으신 거군요.![:흰색_확인_표시:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2705.png) 목표 요약  

- **MSA 구조**: FastAPI 기반 서비스 분리 (`GATEWAY`, `AUTH`)
- `GATEWAY`에서 `/api/users` 요청 → 내부적으로 `AUTH`의 `/users`로 프록시
- Swagger에서 `GET /api/users` → `"Welcome from AUTH"` 메시지 반환

![:흰색_확인_표시:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2705.png) 구조 요약 예시  

GATEWAY/
  app/
    main.py   ← 클라이언트 요청 수신 및 AUTH로 프록시
AUTH/
  app/
    main.py   ← /users 엔드포인트 정의 (Welcome 메시지)

![:흰색_확인_표시:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2705.png) 1. AUTH 서비스: `/users` 엔드포인트 정의  
`**AUTH/app/main.py**`  

from fastapi import FastAPI

app = FastAPI()

@app.get("/users")
def get_users():
    return {"message": "Welcome from AUTH service"}

![:흰색_확인_표시:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2705.png) 2. GATEWAY 서비스: AUTH로 프록시 요청 보내기  
`**GATEWAY/app/main.py**`  

from fastapi import FastAPI
import httpx

app = FastAPI()

# AUTH 서비스의 내부 도커 네트워크 주소 (서비스 이름으로 접근)
AUTH_SERVICE_URL = "[http://auth:8000](http://auth:8000/)"

@app.get("/api/users")
async def proxy_to_auth():
    async with httpx.AsyncClient() as client:
        response = await client.get(f"{AUTH_SERVICE_URL}/users")
        return response.json()

> 여기서 `"``[http://auth:8000](http://auth:8000/)``"`은 `docker-compose.yml`에 정의된 서비스 이름을 기반으로 동작합니다.

![:흰색_확인_표시:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2705.png) 3. docker-compose.yml (GATEWAY + AUTH 포함)  
**최상위에 통합된** `**docker-compose.yml**` **예시:**  

version: "3.9"

services:
  gateway:
    build:
      context: ./GATEWAY
    ports:
      - "8000:8000"
    depends_on:
      - auth

  auth:
    build:
      context: ./AUTH
    ports:
      - "8001:8000"

![:흰색_확인_표시:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2705.png) 4. GATEWAY/Dockerfile & AUTH/Dockerfile (둘 다 동일하게 구성)  

FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY ./app ./app
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

![:흰색_확인_표시:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2705.png) 5. requirements.txt (공통)  

fastapi==0.110.0
uvicorn[standard]==0.29.0
httpx==0.27.0

![:흰색_확인_표시:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2705.png) 6. 실행  
루트 경로에서:  

docker compose up --build -d

![:흰색_확인_표시:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2705.png) 7. Swagger 확인  
**GATEWAY Swagger에서 접속:**  

[http://localhost:8000/docs](http://localhost:8000/docs)

`GET /api/users` 클릭 → **"Welcome from AUTH service"** 메시지 반환 확인![:전구:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/1f4a1.png) 추가 팁  

- 서비스 이름으로 접근 (`auth:8000`)은 docker-compose에서만 가능
- 서비스 디스커버리를 DNS 수준으로 대신하는 구조 (간단하지만 MSA 기반)
- 고급 구조: API Gateway로 `Traefik`, `Kong`, 또는 `Envoy`도 고려 가능

도커 빌드 에러나 실제 요청 실패가 발생하면 로그 캡처 주시면 바로 도와드릴게요.  
 필요하시면 OpenAPI 연동도 gateway 쪽 swagger에 통합하는 것도 가능해요!




### 요약 정리

#### 흐름

Gateway → Proxy→ Service Discovery → Microservices


#### 용어 정리

| 용어                    | 설명                                            |
| --------------------- | --------------------------------------------- |
| **Gateway**           | 모든 외부 요청의 진입점 (API Gateway)                   |
| **Proxy**             | 요청을 실제 서비스로 **전달**해주는 기술적 기능 (프록시 미들웨어 or 함수) |
| **Service Discovery** | 마이크로서비스들의 주소(IP/PORT)를 찾아주는 시스템               |
| **Microservices**     | 기능별로 나뉜 서비스들 (user-service, report-service 등) |

#### 흐름 설명

```
[외부 요청]
   ↓
Gateway (FastAPI 앱 전체)
   ↓
Proxy (요청을 어디로 보낼지 결정)
   ↓
Service Discovery (주소 찾아줌)
   ↓
Microservices (실제 요청 처리)

```

- Gateway는 "문"
    
- Proxy는 "우편배달부"
    
- Service Discovery는 "주소록"
    
- Microservice는 "실제 집"
    

📌 **즉, Proxy는 Gateway 내부에 포함된 기능이고, 그 Proxy가 Service Discovery를 참고해서 전달해줌**

즉, Gateway = 요청을 받아서 → 내부 Proxy로 처리 → 그 Proxy가 Service Discovery를 참고 → 요청 전달


#### 도식 설명

```
                    🔽 사용자 요청 (Next.js)
┌────────────────────────────────────────────┐
│              Gateway (FastAPI)            │
│  ┌──────────────────────────────────────┐  │
│  │        Proxy (라우팅 로직)           │  │
│  │   → 서비스 이름으로 Service Lookup   │  │
│  │   → Service Discovery 조회           │  │
│  │   → 해당 서비스로 전달 (프록시 요청) │  │
│  └──────────────────────────────────────┘  │
└────────────────────────────────────────────┘
                    ↓
        Microservice (user, report 등)

```
