
### 오늘의 수업: 모든 동기 방식을 비동기 방식으로 바꿈! 추가로, singleton과 main 라우터를 연결하였다. 

뷰가 분리되야 비동기가 되어야 한다.

FastAPI에서 

MSA구조이면 비동기이다. 
일괄 동기화 되지 않고, 프로세스가 차례대로 들어오는 것.. (Self, This)

self - 연관
this - 의존()


Pydantic의 `BaseModel`이란?

**Python 객체를 JSON 형식으로 변환하고, 데이터 검증 및 직렬화를 수행하는 핵심 클래스**입니다.

## **📌 1. `BaseModel`의 역할**()

1. **데이터 구조(모델) 정의**  
    → Python의 `dataclass`처럼 사용 가능
2. **자동 데이터 검증**  
    → 잘못된 데이터 입력 시 예외 발생
3. **데이터 타입 변환**  
    → 문자열을 숫자로 변환하는 등의 기능 제공
4. **JSON 변환 및 직렬화 지원**  
    → `.json()`, `.dict()` 메서드를 사용하여 변환 가능

#### base: 구조적 저장소, 여기서 구조는 순차적으로 진행되는 것을 의미함.
## **📌 2. `BaseModel` 사용 예제**

### **✅ (1) 기본 사용법**

```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str
    email: str

user_data = {"id": "1", "name": "Alice", "email": "alice@example.com"}
user = User(**user_data)

print(user)  # 자동 변환 및 검증 수행

```

📌 **출력 결과**

```python
id=1 name='Alice' email='alice@example.com'

```

- `id="1"`(문자열)이지만, 자동으로 `int`로 변환됨! 🚀
- 데이터가 모델 정의와 다르면 오류 발생




### 클래스 앞에 있는 것을 모듈이다. 
예) pydantic.BaseModel 여기에서 pydantic은 모듈이고, BaseModel은 클래스이다. 왜 모듈인지 알았냐면, 뒤에 클래스가 있기 때문이다. 그리고 클래스인지 어떻게 알았냐면 대문자로 시작하기 때문이다.




상수: 내 마음대로 바꿀 수 있는 수


## 조심해야 할 것: 우리는 모두 지금부터 비동기 방식으로 진행할 것이다. 동기 방식(sync)은 레거시 이다. 그리고 라우터에 클래스가 존재하면 안된다. 


### 비동기 방식과 동기 방식의 차이점
- 비동기 방식 - async - 지연 시간을 줌 - 멀티 스레드가 가능함 - Fast API의 디폴트 값 (MSA 구조)

- 동기 방식 - sync - 동시에 일어남 (예: 전화통화), 한꺼번에 많은 일을 할 수 없음. - 단일 스레드 - Flask의 디폴트 값

#### Self = 내장 변수 = sync = 동기
그리고 추가적으로  __ tablename __ 에 대한 설명을 해주면서 예시) self. __ 에 대해 설명해주심.
#### this = async = 비동기


### 환경변수: 상수로 정의 내림.

- 변수값을 사용하는 동안만 고정되어야 하는게 환경변수라고 함. 즉, 상수임
- 그리고 사용하는 동안 .env 파일을 만들어서 마음대로 바꿀 수 있음
- 상수는 변하지 않는 그 값이 유지되는 지속적인 공간을 의미함....
- 예) 내가 살고 있는 집 주소, 내 이름, 내 



### 클래스에 대한 추가적인 정의: 은닉화
- 클래스를 만드는 것을 은닉화라고 부르기로 했다.
- 은닉화는 보안에 관련되어 있다.



### 객체 지향 4가지 순서 정리

#### 객체지향은 상추다!
1. 객체 지향
2. 은닉화(캡슐화): 캡슐화를 하기 위해서 클래스가 반드시 존재해야한다.
3. 상속(abstract할때, abstract인 부모가 자식한테 sub애들한테...상속해줌)
4. 추상화(service할 때 했었다고 한다....)


추가로, 클래스가 존재해야 캡슐화가 이루어 진다.


### 모델 종류
1. pydentic의 모델: 스키마
2. 오픈 ai의 모델: 쳇 gpt
3. SQLAlchemy의 모델: entity(SQLAlchema가 만든 모델)


### 모델 종류(3가지): 범위가 좀 넓음,,,.?
1. 데이터 클래스
2. BaseModel(라우터에서 레파지토리로 이동할 때 Basemodel을 사용함.)
3. entity(함수에서 기능이 빠진 것)


### BaseModel

- 저장에 특화된 모델이다.

### Pydantic

- 데이터 검증 및 설정(Install) 관리(CRUD) 라이브러리라고 한다.

### Constraint VS Violation

- Constraint: 아예 허용되지 않는 것(예를 들어, 비밀번호 8 자리 이내 같은 경우), Must느낌
- Violation: 약간의 허용이 가능함, Should 느낌



### PK(Primary Key)
- 단, 하나만 존재할 수 있는 것
- unique함을 유지할 수 있는 것
- 예) User_ID, 주민 번호 같은 경우

### ORM, SQLAlchema, Postgres, SQL의 관계

#### ORM
- 번역 과정을 위한 시스템
- 여기서 M은 mapping을 의미함.

#### SQLAlchema
- 번역사
- 모든 언어를 파이썬으로 바꿈

#### SQL
- 외계어

#### Postgres
- SQL(외계어)의 한 종류

#### Session
- 번역이 일어나는 장소

#### ORM과정
- SQLALchema가 SQL을 ORM을 돌려서 파이썬으로 번역한다. 그 장소를 session이라고 한다.



### filed와 method의 차이점
- 전체 영역을 field라고 한다.
- 부분 영역을 method라고 한다.
- 메소드는 각자의 기능이 따로 있고, 전체 클래스에서 메소드가 다 필요하지 않다.


#### dependency = install = 주입










