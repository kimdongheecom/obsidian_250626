
### 명령어 실행

docker ps - 도커 상태를 확인하는 것
(도커 위에 올려진 컨테이너의 개수가 몇개인지 확인하는 것이다. 나는 지금 백엔드, 프론트엔드, redis, pgadmin의 컨테이너가 잘 돌아가는지 확인할 수 있다. )

만약 컨테이너가 4개 중 2개만 보인다. 그렇다면! docker compose up -d 명령어 실행하기
컨테이너가 4개 중 4개가 돌아간다. 그러면 docker compose up 명령어 실행하기 (새로고침하기)

docker compose up  - 메모리(브라우저)에 올리는 것은 도커 컴포즈 업이라고 한다. 메모리에 올리면 보인다.

docker compose down - 디스크로 내리는 것을 의미함. 디스크에 있으면 안보인다.


### CPU, 메모리, 디스크

CPU, 메모리, 디스크의 조합은 컴퓨터 조합이다. 커서는 CPU에 있다. 메모리 코드는 직접 볼 수 없다. 

캐쉬 메모리 - CPU에 있지만 메모리에서 일한다. 

가상 메모리 - 디스크에 놔둔 메모리이다. 실제 본질은 디스크이다.


### 디스크와 메모리의 차이점

디스크에 넣으면 다 용량을 잡아먹는다.
인터넷을 켜서 보이는 것은 메모리이고, 인터넷을 끄고 실행되는 것은 디스크이다.
검은 화면은 디스크에 저장되어 있고, 하얀 화면은 메모리에 올라가 있다.디스크는 세이브. 메모리는 로딩
다운로드하겠다는 것은 다 디스크에 있다. 근데 사용할 때만 메모리에 올리는 것이라 생각하면 된다.


### Docker 관련

도커는 올리는 짐꾼이라고 생각해라.

브라우저에 보여지게 하는 것을 가상화 시킨다고 한다. 
#### 위치
도커의 위치: 디스크에 있다. 
브라우저는 디스크에 있다.

다운로드하겠다는 것은 다 디스크에 있다. 근데 사용할 때만 메모리에 올리는 것이라 생각하면 된다.

#### 도커의 역할

도커는 디스크에 저장되어 있지만, up하면 메모리에 올라가게 해준다. 도커는 메모리인 척만 한다.
도커는 디스크에 존재하지만, 도커가 컨테이너를 메모리에 올렸다 라고 해야한다.

디스크 --> 메모리 : docker compose up
메모리 --> 디스크 : docker compose down 
#### docker images와  docker ps의 차이점

![[Pasted image 20250403095318.png]]

- 이름이 있으면 객체로 존재한다.
- 사이즈가 있고 --> 디스크에 저장되어 잇다.(docker images)
- 사이즈가 없다 --> 메모리에 저장되어 있다.(docker ps)

### Container, Images, Volum

이미지가 컨테이너로 메모리에 올라가는데, 
볼륨 : 디스크에 있다. 
볼륨에 넣는다는 것은 디스크에 저장한다는 것을 의미함.
#### Volum 예시) 
볼륨은 디스크에 있다. 볼륨에 넣는다는 것은 디스크에 저장한다는 것을 의미함. 메모리를 통해서 디스크에 값을 저장하는 것을 볼륨의 역할이다. 볼륨은 메모리와 디스크를 연동 시켜 준다. (이런 종류를 크로스라고 한다.)
예시) 크롬으로 따지면.....북마크에 있는것 다 저장해야되니까 다 볼륨이라고 생각했다.
#### images 
예시) 크롬으로 따지면,,,,,크롬 설치했을 때

#### Container 크롬 브라우저가 뜨는 것
예시) 크롬으로 따지면, 크롬 브라우저가 뜨는 것

### 크로스(범용적인 단어)
- 교차로 생각해라....서로 연결시켜준다. 
- 크롤링 할때, 도메인 여러개 가져오는 것을 크로스라고 한다.
- User가 가지고 있는 것들 여러 개의 파일들을 다 가져와야 한다. 이럴 때, 크로스를 가져와야 한다. 
- 여러 개의 정보를 가져올 수 있는 여러 개의 entity를 cross entity라고 한다.(준영이가 한 말)

#### Cross Origin
- 


Resourse: 데이터
### Uniform
- HTTP에 따라 표준화 된 자원 표기법을 의미함. 공인 받은 것.....

postgreSQL에서 전체 테이블 보는 쿼리는 ??


✅ 3. **현재 스키마의 테이블만 보기** (보통 `public`)

```
SELECT tablename
FROM pg_tables
WHERE schemaname = 'public';

```

아래 예시

![[Pasted image 20250403120742.png]]

![[Pasted image 20250403121818.png]]

#### 개수 확인하기 명령어
![[Pasted image 20250403122954.png]]



### 오류 수정

1. postgresql에서 위의 그림 member table 제외하고, 나머지 table을 완전히 삭제해줘.
```
DROP TABLE IF EXISTS player, schedule, stadium, team CASCADE;

```
2.  선생님 링크 따라서 실행 순서대로 execute하기
 https://parksrazor.tistory.com/892

3.  https://parksrazor.tistory.com/117 에 들어가서 쿼리 테스트용 시험해보기





# 백엔드 한국어 패치 (디폴트)

 
 ### 간단 요약!
 

백엔드는 한국어 패치로 디폴트 하기 위해 다음과 같은 작업을 수행한다.

..기원 전

수업을 하면서 축구 문제를 풀기 시작했다.

축구 문제, 전체 축구팀 목록을 팀이름 오름차순으로 출력하시오!

이 문제를 풀기 위해 한국어 패치를 적용해야만 했다.

수정해야할 부분(선생님 깃허브 봐서 추가 수정하기)

1. docker-compose.yml
    
2. docker 폴더 및 파일 생성
    

이러한 작업을 모두 마쳤으면, 디비는 초기화 시켜야 한다.

그리고 유저 테이블 다시 만들고, pgadmin을 다시 반복해주면 된다.
 
 

한국어 패치 깔려고 지금 docker-compose.yml에 설정하는 방법(지금 디폴트가 영어로 되어 있어서 한국어로 디폴트하기 위해 다음과 같은 작업을 함.)

```docker-compose.yml
services:

  database:

    build:

      context: .

      dockerfile: /docker/database/Dockerfile

    container_name: database

    restart: always

    environment:

      POSTGRES_USER: myuser

      POSTGRES_PASSWORD: mypass

      POSTGRES_DB: mydb

    ports:

      - "5432:5432"

    volumes:

      - postgres_data:/var/lib/postgresql/data

  

  backend:

    build:

      context: .

      dockerfile: /docker/backend/Dockerfile

    container_name: backend

    restart: always

    ports:

      - "8000:8000"

    volumes:

      - .:/com/kimdonghee

    working_dir: /com/kimdonghee

    depends_on:

      - database  # database가 먼저 실행되도록 설정

    env_file:

      - .env

    command: [ "uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--reload" ]

  

  redis:

    image: redis:7

    container_name: redis

    ports:

      - "6379:6379"

    restart: always

  pgadmin:

    image: dpage/pgadmin4

    container_name: pgadmin

    restart: always

    environment:

      PGADMIN_DEFAULT_EMAIL: ehdgml2754@gmail.com

      PGADMIN_DEFAULT_PASSWORD: 123456

    ports:

      - "8080:80"

    depends_on:

      - database

  

volumes:

  postgres_data:
```

2. 도커 폴더 및 파일 생성(깃 허브 보면서 수정하기)
![[Pasted image 20250403190236.png]]

도커 야믈 고쳤으면, 도커는 초기화 시켜야함... 그래서 아래 명령어를 순서대로 하기


✅  **모든 관련 도커 리소스 삭제**

```
# 컨테이너 중지 및 삭제
docker-compose down --volumes --remove-orphans

# 이미지 수동 삭제 (선택사항)
docker rmi postgres:latest redis:7 dpage/pgadmin4

# 사용하지 않는 도커 이미지, 컨테이너, 네트워크, 볼륨 모두 삭제
docker system prune -a --volumes

# 볼륨 삭제
docker volume rm postgres_data

```

그리고 다시 빌드하기 위해 아래와 같은 명령어를 사용해야함. 엄청 깨끗하면 이런 명령어를 사용해야 함.

```
docker-compose up --build -d
```


✅ 테이블 insert하기...(아래 처럼 만들기)


![[Pasted image 20250403162110.png]]

1. 처음에 docker ps 하기
2. docker compose up 하기 (새로고침)
3. docker exec -it database  psql -U myuser -d mydb (도커 안에 들어가기)
4. 테이블을 이제부터 만들면 된다.
5. 아래 코드 넣기
```
CREATE TABLE member (

    user_id VARCHAR(15) PRIMARY KEY,

    email VARCHAR(20) UNIQUE NOT NULL,

    password VARCHAR(15) NOT NULL,

    name VARCHAR(10) NOT NULL

);
```

```
INSERT INTO member (user_id, email, password, name)

VALUES

('user01', 'user01@example.com', 'pass123', 'Alice'),

('user02', 'user02@example.com', 'secure456', 'Bob');
```

```
SELECT * FROM member;
```

그 다음에 pgadmin에 들어가기(localhost:8080에 들어가면 된다) --> 포트번호 docker ps확인하기.

#### SQL vs HTML

- 디비에서 사용하는 언어를 SQL이라고 한다. 즉, SQL언어로 쿼리문을 만든다고 생각하면 되!

- 화면에서 사용하는 언어를 HTML이라고 한다. HTML언어를 사용해서 가상 돔이라고 생각하면되! 쿼리는 조건을 걸어서 요청하는 것이다. where절이나 when 절이 쿼리 문이다.


**Table과 View의 차이점**
![[Pasted image 20250403182643.png]]

- table = 실존하는 테이블 (디스크에 있다), 테이블은 디스크처럼 작동한다.
    
- view = 가상 테이블(메모리에 있다)
    
- 작동 원리: 테이블을 메모리에 띄우면 '뷰'가 된다. 그리고 추가적으로, 뷰를 통해서 데이터를 table에 넣는 것이다.
    

**스칼라 vs 인라인 뷰 vs 서브 쿼리**(우리는 3개를 모두 서브쿼리라고 할 수 있다.)

스칼라

- return 뒤에 값이 하나만 나옴. 파이썬에서 DB에서 싱글턴을 스칼라라고 한다. 
    
- 예시)
    
- select ( )
    
- from
    
- where
    

인라인 뷰 : 뷰 안에 있는 뷰를 의미함.

- 로직이 복잡할 때 사용됨. 루프가 걸릴 때 사용됨, 리턴 값이 많으면 사용됨.
    
- 예시)
    
- select
    
- from ( )
    
- where
    

서브쿼리

- 로직이 복잡할 때 사용됨. if가 사용될 때 사용됨…
    
- 서브쿼리는 select 안에 또 select가 있는 경우를 의미함.
    
- 예시)
    
- select
    
- from
    
- where( )
    

**Join**

- 총 3개로 분리됨 (inner join, left join, full join)
    
- 쿼리문에서 제일 어렵다. 듀 개 이상의 테이블이 필요하다. 두 개의 테이블이 합쳐져서 새로운 테이블을 만든다. 조합하는 것과 같다. 두 개의 테이블에서 각각 뽑고 싶은 것을 뽑아서 조합해서 하나의 좋은 테이블을 만듬.
    
-    inner join:교집합 된것만 나온다.
    
    full outer join: 합집합 된것 다 나온다.
    
    left join: from에서 먼저 언급된 테이블을 기준으로 뷰를 만든다.
    
    right join : from에서 두번째로 언급된 테이블을 기준으로 뷰를 만든다. (사용 잘 안함)

- join point: from에서 호출되는 모든 지점
    

**SQL언어로 된 기본 구조**

select → 생략 불가능

from → 생략 불가능

where → 생략 가능,,,, 개인에 대한 조건을 써넣는 곳

group by → 생략 가능,,그룹별로 뽑고 싶을 때 씀. 예) 여성만 뽑고 싶을때, 남성만 뽑고싶을 때 사용

having → 그룹에 대한 조건이 붙을 때 사용, (이건 기본구조에 속하지 않음)

order by

**SQL언어로 된 문법 참고하기**

- from + 도메인(=뷰, 즉 테이블을 생각해라)
    
- where (=if 처럼 생각해라)
    
- % :복수를 의미함

- select = return(커서가 맨 마지막에 읽는다.커서는 from부터 읽는다.그리고 쭉내려간다. 그리고 마지막에 return값을 읽는다.)
-  sql언어를 잘 사용하고, 문법을 잘 구현하여 DB가 답을 올바르게 할 수 있도록 해야한다. 
    

**SQL 언어로 되어 있는 부분에서 where vs when**

- where일 경우, if 하나만 있을 경우에 쓴다.
    
- when 일 경우, if와 elif가 있을 경우에 쓴다.(조건문이 2개 있을 경우에 사용됨)



