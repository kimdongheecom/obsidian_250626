
# 프론트 엔드에서 구글 계정 로그인후, 구글 정책 인증 완료 후, 토큰 발급 완료 후 proxy 서버에서 검증 전까지의 과정
### 흐름 파악
1. 로그인 버튼 클릭 **\src\app\page.tsx**
2.  구글 계정으로 로그인 버튼 클릭 -->  onClick={handleGoogleLogin} 콜백 함수 실행
![[Pasted image 20250410182058.png]]

3.  콜백 함수가 실행되는 곳... try부터 시작된다. 근데 여기에서 그러면 아직은 구글에 들어가지 않은 곳이다.  이 창은 next auth에서 띄운 곳이다. 여기서 signin함수가 nextauth 라이브러리에서 실행된다. 
```
const handleGoogleLogin = async () => {

    try {

      const result = await signIn('google', {

        callbackUrl: '/',

        redirect: false

      });

      console.log('🎯 Login Result:', result);

    } catch (error) {

      console.error('❌ Login failed:', error);

    }

  };
```

[...nextauth]의 의미:
... 은 auth code, access token, refresh token을 의미함.

[ ] : 단수를 의미함. 그리고 폴더 경로를 의미함.
[... ] : 복수를 의미함

예) /api/user/[id] : 여기에서 id에는 변할 수 있는 값이 들어간다고 했다. /api/user 이 부분은 static이고, [id] 부분은 dynamic이다.
- dynamic 부분은 베러블이다. 변할 수 있는 곳... 즉 개인만이 사용할 수 있는 페이지를 의미함. 예) 마이 페이지

예) /api/user/[...nextauth] : 여기에서 ...은 auth code와 access token, refresh token을 의미함.



예) /api/user/kim : 여기는 다 static이다.


4. nextauth는 src\app\api\auth\[...nextauth]\route.ts 여기에서 실행된다. 그 파일에 들어가 봤더니 ... 여기에서 구글 서버로 부터 access token과 refresh token을 받는다. 

```
callbacks: {

    async jwt({ token, account }) {

      if (account) {

        token.accessToken = account.access_token;

        token.refreshToken = account.refresh_token;

      }

      return token;

    },

    async session({ session, token }) {

      // @ts-ignore

      session.accessToken = token.accessToken;

      // @ts-ignore

      session.refreshToken = token.refreshToken;

      return session;

    },
```

5. 그런데 .env.local 파일에 들어가면 우리가 구글 api로부터 미리 받은 키가 있다. 아래에 있는 키(왼쪽에 있는 키...여기는 키엔 벨류 구조로 되어있음)가 있다. post를 통해서 .env.local에 있는 키를 구글서버에 주고, 구글 서버가 키 값을 확인하고,구글 서버가 인증한 후에 get을 통해서  access token과 refresh token을 구글 서버로 부터 가져온다. 

```
NEXT_PUBLIC_API_URL=http://localhost:8000/api

GOOGLE_CLIENT_ID=[YOUR_GOOGLE_CLIENT_ID_HERE]

GOOGLE_CLIENT_SECRET=[YOUR_GOOGLE_CLIENT_SECRET_HERE]

NEXTAUTH_URL=http://localhost:3000

NEXTAUTH_SECRET=[YOUR_NEXTAUTH_SECRET_HERE]
```


아래는 구글 서버에서 데이터를 가지고 올 때는 get이라고 이름을 붙였고, 구글 서버에 인증할 때에는 post라고 이름을 붙였다.  
```
export const GET = handler;

export const POST = handler;
```

6. access_token과 refresh_token을 가져오는 곳은 아래와 같다.
```
callbacks: {

    async jwt({ token, account }) {

      if (account) {

        token.accessToken = account.access_token;

        token.refreshToken = account.refresh_token;

      }

      return token;

    },

    async session({ session, token }) {

      // @ts-ignore

      session.accessToken = token.accessToken;

      // @ts-ignore

      session.refreshToken = token.refreshToken;

      return session;

    },

  },

};
```

7. 여기서 가져오면....login/page.tsx에서 아래와 같이 로깅(프린트 출력?)이 찍힌다. 그 부분은 아래 코드를 참조하시오.

![[Pasted image 20250410185108.png]]

코드 구현한 곳은 아래를 보시오. 여기에서 로깅이 찍히는 곳이다. 브라우저에서 f12를 누르면 저렇게 콘솔창에 access_token과 refresh_token을 찍히게 하는 곳은 바로 아래이다. 사진은 위를 참고하면 된다. 

```
  useEffect(() => {

    if (session && !isLogged) {

      setIsLogged(true);

      console.log('🔵 Session Status:', status);

      console.log('🔵 Session Data:', session);

      console.log('👧🏻👧🏻👧🏻👧🏻Access Token:', session.accessToken);

      console.log('🦣🦣🦣🦣Refresh Token:', session.refreshToken);

      if (session.accessToken) {

        router.push('/');  // 로그인 성공 시 메인 페이지로 이동

      }

    }
```

토큰을 발급하는 것은 구글 서버가 하지만, 토큰을 가지고 오고 하는 것은 nextauth 라이브러리가 하고....
토큰을 검증하는 곳은 프록시 서버인데, 여기에서 jose가 움직인다.

access_token을 발급받을 때  --> 비밀 키를 사용한다.
access_token을 검증받을 때 --> 공개 키를 사용한다.

비밀키는 오직 google만 갖고 있고, 공개키는 모두(Jose)에게 공개해서 누구나(Jose) 토큰의 유효성을 검증할 수 있게 함.

![[Pasted image 20250410190611.png]]

#### 중요한 점
- code=... 이 auth code를 받는 곳이다. 이 부분은 콘솔창에 띄어 있었다.  
- NextAuth 서버가 auth 코드를 사용해서 구글에게 access_token과 refresh_token을 받아옴.  브라우저 URL에 access token이나 refresh token은 직접 노출되지 않는다.(쿼리 스트링에는 access token과 refresh token이 안보인다.)
- 