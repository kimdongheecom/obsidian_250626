
### LGCNS의 재무상태표 스크랩핑 하는 방법


#### 정적 크롤링과 동적크롤링의 차이

- 정적: 가져온 데이터가 쉘로우(html안에 있다)고, 시간에 따라 안변한다.

- 동적: 딥(파이썬에 있다)에 있다. 시간에 따라서 변한다.


목표
-  fastAPI기반으로 lgcns 정적 크롤링하기


항상 먼저 단계별로 프롬프팅을 해야한다. 

항상 먼저 프레임을 짜야한다. 프레임 워크를 말해줘야한다. 



**질문.  https://dart.fss.or.kr/에서 lgcns의 제무상태표를 스크랩핑을 하고 싶어. fastapi에서 크롤링할꺼야.파일명은 lgcns_service.py로 작성해줘. 그리고 일단은 콘솔에 출력할꺼야.**

좋아! `FastAPI`에서 DART의 LG CNS 재무상태표를 크롤링해서 콘솔에 출력하는 코드를 `lgcns_service.py`라는 파일로 작성해줄게.  
DART는 공개 API를 제공하므로, 크롤링보다는 API 사용이 일반적이야. 하지만 크롤링이 목적이라면 HTML 파싱 방식으로 대응할 수도 있어.

우선 아래는 **크롤링 방식**으로 LG CNS 재무상태표를 가져와 콘솔에 출력하는 예시야.  
(LG CNS의 보고서가 있는 DART의 전자공시 시스템에서 HTML을 파싱하는 방식)

---

### ✅ `lgcns_service.py` (FastAPI 내 서비스 모듈 예시)

```python
import requests
from bs4 import BeautifulSoup
from fastapi import APIRouter

router = APIRouter()

@router.get("/lgcns/bs")
def get_lgcns_balance_sheet():
    # LG CNS 사업보고서 검색 (보고서 목록 가져오기)
    search_url = "https://dart.fss.or.kr/dsaf001/main.do?rcpNo=20240315000068"  # 예시: LG CNS 2023 사업보고서 rcpNo
    headers = {
        "User-Agent": "Mozilla/5.0"
    }

    try:
        response = requests.get(search_url, headers=headers)
        response.raise_for_status()
        soup = BeautifulSoup(response.content, "html.parser")

        # 재무제표 iframe 링크 추출
        iframe = soup.find("iframe")
        if iframe:
            iframe_src = iframe["src"]
            iframe_url = f"https://dart.fss.or.kr{iframe_src}"

            iframe_res = requests.get(iframe_url, headers=headers)
            iframe_soup = BeautifulSoup(iframe_res.content, "html.parser")

            # 재무상태표 추출 (표 태그에서 '재무상태표' 포함된 테이블 찾기)
            tables = iframe_soup.find_all("table")
            for table in tables:
                if "재무상태표" in table.get_text():
                    print("\n[재무상태표]")
                    print(table.get_text())
                    break
            else:
                print("재무상태표를 찾을 수 없습니다.")
        else:
            print("iframe을 찾을 수 없습니다.")

    except requests.exceptions.RequestException as e:
        print(f"요청 중 오류 발생: {e}")
```

---

### 📝 설명:

- `https://dart.fss.or.kr/dsaf001/main.do?rcpNo=...` : `rcpNo`는 특정 보고서의 고유번호야. 최신 보고서의 `rcpNo`는 DART 검색 또는 API를 통해 찾아야 해.
    
- 이 코드는 정해진 보고서(`rcpNo=20240315000068`)의 재무상태표를 HTML에서 찾는 구조야.
    
- 현재는 FastAPI의 엔드포인트 `/lgcns/bs`에서 요청 시 콘솔에 출력만 해.
    
- 향후 반환값을 JSON으로 바꾸고, 자동으로 `rcpNo`를 검색하는 기능도 넣을 수 있어.
    

---

### ✅ 실행 예시:

FastAPI 앱에서 이 라우터를 등록해야 해.

```python
from fastapi import FastAPI
from lgcns_service import router as lgcns_router

app = FastAPI()
app.include_router(lgcns_router)
```

---

### 📌 다음 단계 (선택사항):

- 최신 보고서 자동 검색 (공시 목록에서 `LG CNS` 키워드로 rcpNo 추출)
    
- `재무상태표` → pandas DataFrame으로 변환
    
- 콘솔 출력 대신 JSON으로 반환
    
- DB에 저장하는 기능
    

---

혹시 위 코드에서 특정 연도의 보고서를 자동으로 찾는 기능도 추가해줄까?

**질문. 여기에 fastAPI를 설치할거야. 이것을 실행해서 swagger로 hellow world가 출력되도록 작성해줘.**

좋아! 지금 네가 사용 중인 환경(예: Cursor IDE)에서 FastAPI 프로젝트를 만들고, Swagger UI에서 "Hello World"가 출력되도록 설정하려면 다음 단계를 따르면 돼.

---

### ✅ 1. FastAPI와 Uvicorn 설치

터미널을 열고 다음 명령어 입력:(이건 하지 말기)

**pip install fastapi uvicorn 이것 대신에  requirements.txt로 하고, 실행을 Dockerfile, docker-compose up -d로 하도록 해줘.(이렇게 해야함)**


```bash
pip install fastapi uvicorn
```

---

### ✅ 2. `main.py` 생성 및 코드 작성

`main.py` 파일을 프로젝트 루트 디렉토리에 만들고 아래처럼 작성해:

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"message": "Hello World"}
```

---

### ✅ 3. FastAPI 서버 실행

터미널에서 다음 명령어 실행:

```bash
uvicorn main:app --reload
```

---

### ✅ 4. Swagger UI 접속

브라우저에서 아래 주소로 접속:

```
http://127.0.0.1:8000/docs
```

여기서 `"GET /"` 경로를 클릭하면 **"Hello World"** 메시지를 확인할 수 있어!

---

필요하다면 디렉토리 구조도 정리해줄게!  
혹시 `lgcns_service.py`도 함께 구성해서 `/lgcns/bs` 같은 경로도 등록할까?


**질문. pip install fastapi uvicorn 이것 대신에  requirements.txt로 하고, 실행을 Dockerfile, docker-compose up -d로 하도록 해줘.**

좋아, FastAPI 프로젝트를 Docker 기반으로 실행하고, `requirements.txt`로 의존성 관리하고 `docker-compose up -d`로 실행하려면 아래처럼 구성하면 돼.

---

## ✅ 전체 구성

### 📁 프로젝트 구조 예시

```
lgcns/
├── app/
│   └── main.py
├── requirements.txt
├── Dockerfile
└── docker-compose.yml
```

---

### ✅ 1. `requirements.txt`

```txt
fastapi
uvicorn[standard]
```

---

### ✅ 2. `app/main.py`

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"message": "Hello World"}
```

---

### ✅ 3. `Dockerfile`

```dockerfile
# 베이스 이미지 설정
FROM python:3.10-slim

# 작업 디렉토리 생성
WORKDIR /app

# 의존성 파일 복사 및 설치
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 앱 코드 복사
COPY ./app ./app

# 작업 디렉토리 설정 및 실행
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
```

---

### ✅ 4. `docker-compose.yml`

```yaml
version: "3.9"

services:
  fastapi:
    build: .
    container_name: lgcns-fastapi
    ports:
      - "8000:8000"
    volumes:
      - ./app:/app
    restart: always
```

---

### ✅ 5. 실행 방법

```bash
docker-compose up -d
```

---

### ✅ 6. Swagger UI 확인

브라우저에서 아래 주소 접속:

```
http://localhost:8000/docs
```

---

필요하다면 `/lgcns/bs` 같은 엔드포인트도 `app/lgcns_service.py`로 추가해서 라우팅해줄 수 있어. 계속 진행할까?

**커서 질문.** 

lgcns/  
├── app/  
│ └── main.py  
├── requirements.txt  
├── Dockerfile  
└── docker-compose.yml  
  
이렇게 구조를 작성해줘.



**커서 질문.** 
  
@Dockerfile python 3.12.7으로 변경해주고, port는 8889,리로드 옵션을 넣어줘.



**커서 질문.**  
@main.py 이것을 실행해줘.


도커를 처음에 등록할 때?
docker compose up --build -d이와 같은 명령어 사용하기

만약, 처음에 빌드하는데, 오류가 발생하면 아래 3개의 명령어 작성하기.
docker compose down
docker compose build --no-cache
docker compose up



-- hello world 땅 띄우기 --


지금부터는 도메인과 책임을 분리하는 역할을 할꺼야....



**커서 질문. app 폴더 밑에 서브폴더로 api,domain,foundation,platform를 만들어줘.**



**커서 질문. 앞으로 init.py 파일에 아무것도 넣지마. 지금 init.py에 넣은 것을 삭제해줘.**



**커서 질문. api 밑에 lgcns_router.py 파일을 만들어줘. 도메인 폴더 아래에는 models, controllers, services, repositories 하고, 그리고 만들어진 폴더 아래에는 다음과 같이 파일을 만들어줘. models 폴더 아래에는 lgcns_entity.py와 lgcns_schema.py를 만들어주고, services 폴더 아래에는 lgcns_services.py를 만들어주고, repositories폴더 아래에는  lgcns_repository 파일을 만들어주고, controllers폴더 아래에는 lgcns_controller.py 파일을 만들어줘. 파일 내부는 클래스 이름과 생성자까지만 만들고, 나머지는 만들지마.**

**커서 질문. 그리고 현재 app 밑에 app_router.py를 추가해줘.

  
**커서 질문. @lgcns_router.py 앞으로 router들은 전부 함수형으로 작성해줘. 이것도 함수형으로 변경해줘. 그리고 app_router에서 lgcns_router를 호출하도록 해줘.


**커서 질문. 그리고 앞으로 라우터를 만들라고 하면 반드시 이 형태로 라우터를 생성해줘. 이것 꼭 명심해. (데코레이터를 사용하여 엔드포인트 정의)

**커서 질문. lgcns_router.py를 만들 때 데코레이터를 사용하여 엔드포인트를 정의해줘.


**커서 질문. 추가로, 수정할 부분이 있어. 여기에서 app_router를 삭제하고, 바깥에 있던 main.py를 app 안으로 위치를 변경해줘. 그리고 main.py가 app_router.py의 역할을 할 수 있도록 해줘.


  
**커서 질문. @main.py 여기에서 prefix를 api로 정의해줘.
- LGCNS 관련 엔드포인트는 /api/lgcns/... 형식으로 접근할 수 있습니다. 예를 들어:
- Root 엔드포인트: /api/lgcns/


  
**커서 질문. @main.py 여기에서 app_router를 만들고,app_router에 prefix를 api로 정의해주고, app_router에 lgcns_router를 포함해줘.**


**커서 질문. 이전에 app바깥쪽에 main.py를 두던 방식은 틀렸어. 이렇게 하지말고, 지금의 방식을 기억해.**




추가 설명. 





#### 완성본(LGCNS 폴더 구조)

```
app/
├── main.py (FastAPI 앱 및 라우터 설정)
├── api/
│   └── lgcns_router.py
├── domain/
│   ├── models/
│   │   ├── lgcns_entity.py
│   │   └── lgcns_schema.py
│   ├── controllers/
│   │   └── lgcns_controller.py
│   ├── services/
│   │   └── lgcns_services.py
│   └── repositories/
│       └── lgcns_repository.py
```



쳇 gpt 질문.  https://dart.fss.or.kr/에서 lgcns의 제무상태표를 스크랩핑을 하고 싶어. fastapi에서 크롤링할꺼야.파일명은 lgcns_service.py로 작성해줘. 그리고 일단은 콘솔에 출력할꺼야.


---- 여기까지 크롤링 전까지 폴더 구조 진행하였습니다.---- 


쳇 gpt 질문.  https://dart.fss.or.kr/에서 lgcns의 제무상태표를 스크랩핑을 하고 싶어. fastapi에서 크롤링할꺼야.파일명은 lgcns_service.py로 작성해줘. 그리고 일단은 콘솔에 출력할꺼야.( 다트 공시는 크롤링으로 하는게 아니라 종목코드로 키를 받아서 하는거라 크롤링이 안돼... )




### MVC 패턴과 MSA 패턴의 차이

- MVC 패턴: fastAPI와 NextJS로 나눈 패턴을 의미함. 뷰와 모델로 쪼갠다. --> 쪼그만한 회사....
	-  c : 컨트롤러 즉, 메인 라우터... 컨트롤러 api prefix를 주는 애는 하나이다. 
	
- 모놀리식 패턴: 플라스크가 모놀리식이다. 하나의 앱 만 있다.


- MSA 패턴: 뷰는 한 개이다. 뷰는 안쪼갠다. --> SPA (single page application)기반이다. 뷰는 안 쪼개고, 모델(서비스)을 쪼갠다.  
	- 앱을 만든다는 의미는 msa와 보완 인증까지 걸 수 있는 실력이 된다는 의미이다.
	-  게이트웨이와 라우터
	- api 한 개 만들 것이다. 서비스가 여러 개 분리되어 있다.



#### 분배기와 라우터(MSA 패턴 구조)
- 분배기(메인 라우터, gateway(문짝): 부모): 
	- /api
	- gateway

- 라우터(자식): 
	- /lgcns
	- /samsung


#### msa 패턴에서 서비스 디스커버리란?
- 마이크로서비스들끼리 **서로의 위치(IP, 포트)**를 자동으로 찾고 통신할 수 있도록 도와주는 시스템

잠시... mvc패턴인데 msa패턴으로 변환하려고 해. railway에서 fastAPI로 만들거야.


#### msa 패턴에서 gateway란?

게이트웨이와 서비스디스커버리는 다른 놈이다. 
아마존에서 두 놈은 분리시킨다. (두 놈을 분리시키는게 좋다.)
레일웨이에서는 게이트웨이와 서비스디스커버리를 합칠 것이다. 




질문. 나는 현재 nextjs = fastAPI 하나로 구성된 mvc를 msa 구조로 변경하려고 해. 이때 railway에 배포하고 비용을 최소화 할려고 해서, gateway와 service discovery를 합친 형태로 만들꺼야.나는 지금 처음 만드는 거라 자세히 설명해줘.

좋아, 지금부터 너의 상황을 딱 맞춰서 **처음부터 끝까지 MSA로 바꾸는 구조 + 비용 최소화 + Gateway + Service Discovery 통합 구조**를 이해할 수 있도록 정리해줄게.  
너처럼 처음 만드는 사람도 확실히 이해할 수 있도록 **구조 → 역할 → 배포 방식** 순서로 설명할게.

---

## ✅ 1. 현재 상태 (기존 구조)

```
[Next.js (프론트)]
   ↕️ API 호출
[FastAPI (백엔드)]
```

- 하나의 FastAPI 안에 인증, 게시판, ESG 분석 등 모든 기능이 들어있음 → = 단일 앱 (MVC)
    

---

## ✅ 2. 목표 구조 (MSA 구조)

```
[Next.js]
   ↕️ API 요청 (모든 요청은 게이트웨이로)
[API Gateway (FastAPI)]
   ↔ /auth → Auth 서비스
   ↔ /report → Report 서비스
   ↔ /user → User 서비스
```

- 기능마다 서비스가 나뉘어 있고,
    
- 사용자는 모두 Gateway 하나만 바라봄 (`gateway.up.railway.app`)
    

---

## ✅ 3. 최소 비용으로 배포할 구조 (Railway 활용)

Railway는 **프로젝트당 무료 사용량**이 있으니:

|구성 요소|Railway 프로젝트 구성|
|---|---|
|Gateway|1개 Railway 앱 (프록시 라우팅 + 간단한 디스커버리 기능 포함)|
|Auth 서비스|1개 Railway 앱|
|Report 서비스|1개 Railway 앱|
|DB|Railway PostgreSQL or Supabase 무료|
|프론트엔드|Vercel(Next.js), Railway 웹서비스로 배포 가능|

📌 즉, 전체 구성은 **4개 Railway 앱만으로도 MSA가 가능**해!

---

## ✅ 4. 각 구성 요소 설명 (너무 쉽게)

### 1️⃣ Gateway (FastAPI)

- 사용자 요청을 받아서 적절한 서비스로 전달
    
- 서비스 주소를 관리하고 요청을 프록시
    
- 간단한 Service Discovery 역할까지 겸함
    
    - 예시: `/services.json`에서 각 서비스의 URL을 가져옴
        

### 2️⃣ Microservices

- `/auth`, `/report` 등 기능별로 나뉜 FastAPI 서버
    
- 각각의 앱은 독립적으로 실행되고, Railway에 각각 배포됨
    

### 3️⃣ Service Discovery (간단하게)

- `services.json` 같은 정적 JSON 파일 또는 `.env` 환경변수에서
    
- 각 서비스 주소를 관리함
    

예시:

```json
{
  "auth": "https://auth-service.up.railway.app",
  "report": "https://report-service.up.railway.app"
}
```

---

## ✅ 5. 실제 폴더 구성 (로컬 개발 기준)

```
project-root/
├── gateway/
│   ├── main.py
│   ├── services.json  ← 각 서비스 URL 저장
│   └── requirements.txt
├── auth-service/
│   ├── main.py
│   └── requirements.txt
├── report-service/
│   ├── main.py
│   └── requirements.txt
├── frontend/  ← Next.js
│   └── ...
```

---

## ✅ 6. Gateway 라우팅 예제 (FastAPI)

```python
# gateway/main.py
from fastapi import FastAPI, Request
import httpx
import json

app = FastAPI()

with open("services.json", "r") as f:
    service_map = json.load(f)

@app.api_route("/{service}/{path:path}", methods=["GET", "POST", "PUT", "DELETE"])
async def proxy(service: str, path: str, request: Request):
    if service not in service_map:
        return {"error": f"Service '{service}' not found"}
    
    service_url = service_map[service]
    full_url = f"{service_url}/{path}"
    
    async with httpx.AsyncClient() as client:
        response = await client.request(
            request.method,
            full_url,
            headers=request.headers.raw,
            content=await request.body()
        )
        return response.json()
```

---

## ✅ 7. 배포 순서 (비용 최소화 전략 포함)

1. **FastAPI Gateway** → Railway에 배포 (1개 프로젝트 사용)
    
2. **Auth 서비스**, **Report 서비스** → 각각 Railway에 배포
    
    - 무료 플랜에서도 충분히 운영 가능
        
3. `services.json` 파일에 각 서비스의 Railway 도메인 입력
    
4. 프론트엔드는 Vercel이나 Railway 웹서비스로 배포
    

---

## ✅ 추가 팁: 비용 최소화 전략

|방법|설명|
|---|---|
|Railway Free Tier 사용|서비스 1개당 월 500시간 무료|
|`sleep mode` 설정|사용하지 않으면 자동 절전|
|Docker 대신 Railway GUI 사용|간단한 FastAPI 앱은 직접 배포 가능|
|`.env` 대신 `services.json` 사용|비용 없는 간단한 서비스 디스커버리 방식|

---

## ✅ 정리 요약

|항목|설명|
|---|---|
|구조|Next.js + Gateway + Microservices|
|배포 환경|Railway (최대 4개 앱), Vercel 가능|
|게이트웨이 역할|라우팅 + 간단한 서비스 디스커버리|
|서비스 디스커버리 방식|services.json 또는 환경변수로 간단하게 관리|
|확장성|기능별 서비스 확장, 비용도 최소화 가능|

---

너가 원하면 이 구조를 기반으로 전체 템플릿을 만들어줄 수도 있어!  
또는 각 서비스별 `Dockerfile`, Railway 배포 방법도 하나씩 같이 정리해줄게. 계속 진행할까?