
1. 저는 이제 앞으로 Next.js 프로젝트는 위 이미지처럼 MSA 구조로 만들 예정입니다. 먼저 이미지를 참고해서 폴더를 생성해주세요.
![[Pasted image 20250411110836.png]]

2. app폴더루트에 메인 페이지를 생성하고, app/oauth/login 안에 로그인 페이지를 생성해줘. 그리고 메인페이지에 ‘로그인하기’버튼을 만들어서, 클라이언트가 이 버튼을 누르면 로그인 페이지로 연결되게 해줘

3. app/oauth/login에 있는 로그인 페이지에서 사진과 같은 화면을 띄우고 싶어. 구글, 네이버, 카카오 로그인을 선택할 수 있게 만들어줘. 그리고 구글,네이버,카카오의 로고도 가져와서 만들어줘

4. next.js를 실행하기 위한 도구로 yarn, pnpm설치해줘(둘 중 하나만 선택)

5. 나는 nextauth를 활용해서 구글 OAuth 로그인 기능을 구현할거야. [...nextauth]는 app/api/auth/ 안에 만들어줘. 로그인페이지에 있는 ‘구글로그인’버튼을 클릭했을 때, nextauth를 통해서 구글 서버와 연동되게끔 작업해줘. 그리고 내가 구글클라우드콘솔 페이지에서 어떤 작업을 해야하는지도 알려줘

6. nextauth가 구글서버로부터 받아온 access토큰과 refresh토큰을 브라우저 콘솔창에 띄울 수 있게 코드를 짜줘





스테이트: 시스템이 프로세스에 따라 어떤 행동을 할지 결정해주는 조건을 의미함.

스테이트: 
- 이벤트나 스레드가 이제 이동할 때 시스템이 프로세스에 따라서 어떤 행동을 할지 선택지를 주는 조건이 바로 스테이트이다. 
- 모든 프로세스의 흐름은 데이터의 이동이다. 
- 데이터가 동적으로 바뀔 때 ....조건.....


상태는 조건이 아니다.??

상태는 변화되는게 아니라 대체되는 것이다. 대체되는 것은 변화가 끝난 지점을 의미한다. 





### 현재 상황

구글 서버로 부터 인증을 받았기 때문에 access token과 refresh token을 받았고, 그것들을 브라우저 콘솔에 띄었다. 

-  구글로 부터는 인증을 받았는데, 저희의 서버에서는 인증을 못받았다. 그래서 로그인이 안되었다.
-  우리는 이것을 프록시 서버에 보내야 한다. 그래야 우리 서버에서 인증을 받을 수 있다. 
-  티켓은 access_token이고, 티켓을 재발급하기 위해 놔둔 것을 refresh_token을 말한다.
-  프록시 서버에 들어가기 위해서 access_token과 refresh_token이 필요하다. 그래서 구글 서버에서 가져온 것이다.
-  auth code가 

#### 비밀키 공개키 정리
- 비밀키 - 딱 둘만 아는 것,,,,,(nextauth와 google 서버만 아는 경우를 말함)
- 공개키 -  비밀키를 모두가 아는 것을 의미함.
- auth_code는 백엔드에 절대 주면 안된다.  
### 목표

두 토큰을 가지고 프록시 서버에 보낸다. 

죠스는 프록시 서버에 있다. 죠스가 구글로부터 공개키를 가지고 있었다. 



함수는 호출될 때 실행된다.

1. auth 코드를 받아온 녀석이다. 
![[Pasted image 20250411153300.png]]


![[Pasted image 20250411153729.png]]

![[Pasted image 20250411154239.png]]



4. next에 있는 값이 
![[Pasted image 20250411154346.png]]




프론트엔드는 리프레시 토큰을 직접 다루지 않는다



**NextAuth(프론트 쪽)** 에 `refresh_token`을 보관하거나 재발급 권한을 주는 구조는 이제 **비권장**이다.


```
[1] 클라이언트 → signIn("google") → NextAuth 로그인 요청
[2] NextAuth → Google → access_token + refresh_token 수신
[3] NextAuth → 서버(Proxy/Auth)에 refresh_token 전달
[4] 서버는 refresh_token 저장 (DB/Redis)
[5] 서버가 자체 JWT(access_token) 발급 (jose 이용, RS256)
[6] 클라이언트는 access_token만 저장 (보통 localStorage or cookie)
[7] 만료 시 → 클라이언트가 /auth/refresh API 호출 → 서버에서 재발급

```



구글 서버에서 받은 auth code를 gateway에 전달해야해


auth 
gateway에 넘길때, 게이트 웨이는 검증을 해야한다. 그러면 auth 코드를 제거를 해야한다. 그러면 





**커서 질문,** 
/[...nextauth]@route.ts 이것을 참고로, login.tsx/@page.tsx 내가 설정한 시나리오 1"// axios로 gateway에 접근해서 그곳에 있는 jose에게 access, refresh 토큰을 넘긴다. " 부분과 시나리오2"//gateway에 있는 jose에서 SUCCESS를 받으면,이곳에 있는 jwt를 삭제한다."를 실행하는 코딩을 해줘.