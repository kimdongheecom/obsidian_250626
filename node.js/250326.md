

빌드: 실행 가능한 상태로 만드는 것. 즉, 실행가능한 상태로 만들자라는 의미를 말함.

빌더 패턴을 만들려면 


빌더 패턴: 생성 과정을 분리하는 것.

상태 패턴:
결제를 안한 상태, 결제를 한 상태..방법을 선택하기 전에////////

전략 패턴: 
(방법은 전략 패턴이다.) 방식(메소드: function)을 선택하는 것.


리덕스 홈페이지: https://redux.js.org/

리덕스 : 전역 상태 관리자

관리: CRUD를 생각하라!!!!!


글로벌 

빌드가 들어가면 호이스팅(전역)이 들어간다.

소문자 걸리는 건 다 훅함수가 걸린다.

함수형 프로그래밍은 호이스팅 거는거,... 이런 거 의미한다.

글로벌과 로컬의 차이점:

속성과 기능으로 페이지를 컴포넌트와 훅으로 나뉜다. 


kimdonghee : 전역

page.tsx :로컬이다. 아토믹 패턴에서 최상단 이다. 


기능이 들어가는 모든 것은 다 '훅'에 들어간다.

컨테이너, 훅, 컴포넌트는 다  함수이다.

상태는  노드가 있는데, 엣지를 통해 관계가 형성이 되어있다. 

컨테이너는 상태를 갖게 된다. 







emial:" " 이 부분은 초기화 시키는 것을 의미함.
![[Pasted image 20250326105428.png]]

이메일에 대한 판단... 상태인가???/

![[Pasted image 20250326105609.png]]


OOP는 기능과 속성을 가진 객체로만 되어있어. StateFul인 상태만 있다. stateless가 없다.



"우리가 하는 일은 상태 바꾸는 일이다." 



베어본 스테이트와 글로벌 스테이트의 차이점?
- bearbone state: 최소한의 기능을 갖춘 ...






객체지향의 단점: 느리다.


1. 여기에서 프론트에서 제이슨 형태로 백엔드에 보낸다. 
 try {

      const response = await api.post('/api/auth/login', {

        email: form.email,

        password: form.password

      });

2. 백엔트에서 바디로 제이슨을 받는다. 
3. 그리고 message, body를 프론트엔드로 보낸다.




애플리케이션안에 있는 데이터를 전달하는 방법이 두가지가 있는데, FLUX와 Context가 있어. 우리팀은 ESG기반한 인공지능 개발할거야. 너라면 뭘 추천할꺼야?

###### ChatGPT의 말:

좋아! 이제 **ESG 기반 인공지능 애플리케이션**에서  
**애플리케이션 내에서 데이터를 전달하는 방식**으로 `Flux`와 `Context`를 고민 중이구나?  
아주 좋은 고민이야.  
그럼 두 방식의 **차이점**, **언제 쓰면 좋은지**, **ESG 기반 프로젝트에 어떤 게 적합한지** 같이 정리해줄게! 💡

---

## ✅ 1. Context API란?

> **React에서 컴포넌트 간에 전역 상태를 쉽게 공유하는 방법**

### ✨ 특징

- React에 기본 내장되어 있음 (라이브러리 설치 X)
    
- 간단한 전역 상태 공유에 아주 적합
    
- 예: `Theme`, `로그인 정보`, `언어`, `전역 메시지` 등
    

### 🧠 단점

- 상태가 많아질수록 **성능 저하**
    
- 상태 분기/로직이 복잡해질수록 **관리 어려움**
    

---

## ✅ 2. Flux (예: Redux, Recoil 등)

> **단방향 데이터 흐름(One-way Data Flow)을 기반으로 하는 상태 관리 아키텍처**

### ✨ 특징

- 모든 상태 변화는 **액션 → 리듀서 → 새로운 상태** 흐름을 따름
    
- 대규모 앱, 복잡한 로직 관리에 적합
    
- 개발자 도구(디버깅, 기록, time-travel 등) 강력
    

### 🧠 단점

- 보일러플레이트(코드량)이 많아질 수 있음
    
- 설정/초기 진입장벽이 조금 있음
    

---

## 🎯 ESG 인공지능 앱에서 뭘 선택하면 좋을까?

### 🔍 ESG 기반 인공지능의 특징을 살펴보면:

|항목|설명|
|---|---|
|📊 데이터 많음|ESG 지표, 기업 리포트, AI 추론 결과 등|
|🤖 예측/분석 많음|모델 출력값, 분석 피드백 등|
|🧭 사용자/역할 많음|관리자, 분석가, 리포트 사용자 등|

👉 즉, **상태가 복잡하고 관리가 중요한 구조**임

---

## ✅ 결론

|상황|추천 방식|
|---|---|
|앱이 작고 간단할 때|Context API 👍|
|데이터 흐름이 단순하고 일회성일 때|Context API OK|
|ESG AI 시스템처럼 복잡하고 규모가 클 때|**Flux 계열(Redux, Recoil 등)** 권장 ✅|

---

## ✨ 보너스: 둘을 같이 쓰는 방법도 있어!

- **Context API로 로그인/언어/모드** 같은 단순한 전역값 관리
    
- **Redux 또는 Recoil로 ESG 분석 결과, 모델 출력 상태 관리**
    

---

원하면 ESG 분석 앱에 맞는 상태 관리 구조 (예: 상태 트리 설계) 예시도 같이 그려줄게 🔥  
어떤 라이브러리(Redux, Zustand, Recoil 등)를 염두에 두고 있어?



### 플럭스 패턴: 자동으로 화면을 알아서 움직이게 해주는 패턴.. 이걸 리덕스가 플랙스 패턴으로 조종한다. 



스테이트와 리듀서????

액션이 

뷰(=컴포넌트)

미리 만들어진 게 예측하는 것이다......

로그인 성공하면 "김동희님 로그인 성공하셨습니다" --> view에 저장됨

action --> 대시보드로 바뀜

유저 정보를 담아줘야한다 acition에

상태를 저장한다 = 상태를 업데이트 한다. 

리듀서는 store 안에 있다.

action과 dispatcher는 리엑트에 있다. 

store에는 state가 저장되어 있다. 상태가 업데이트 되어있다.

액션이 리엑트에서 발생하면, 디스페쳐에 의해 스토어(이미 스테이트가 있음)에 ...스테이트가 바뀌면 뭐 해줘라 라고 리듀서가 코드를 짜줘야 한다. 

호이스팅: 대문자로 걸면 된다. 에로우 펑션 쓸꺼야.

훅:  펑션을 쓸꺼야. 소문자로 걸면 된다.


디스페쳐는 컴포넌트에 파견나와있다.

액션은 컴포넌트에서 ....?

리듀서:  ??/


현재 상태(이니셜 스테이트)에서 다음 상태로 스토어에 저장되면..... 현재 상태가 사라진다. 이것을 업데이트되었다///??/


아래가 rawSQL방식을 쓴거다. CORE방식이다.
![[Pasted image 20250326165602.png]]


import { useState } from "react";

import api from '@/lib/axios'

import { useAuthStore } from "@/store/account/auth/user/store";

import router from "next/router";

interface LoginFormState {

email: string;

password: string;

}

export default function useLoginForm() {

const [form, setForm] = useState<LoginFormState>({

email: "",

password: "",

});

const [error, setError] = useState<string>("");

const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {

setForm({ ...form, [e.target.name]: e.target.value });

};

const handleSubmit = async (e: React.FormEvent) => {

e.preventDefault();

if (!form.email || !form.password) {

setError("이메일과 비밀번호를 입력하세요.");

return;

}

setError("");

console.log("로그인 요청", form);

try {

const response = await api.post('/api/auth/login', {

email: form.email,

password: form.password

});

console.log("로그인 성공", response.data);

const message = response.data.message ///message 언박씽하는 과정, 아래도 언박씽하는 과정

const logged_in_user = response.data.logged_in_user

//zustand에 저장

if (message === "로그인에 성공했습니다")

router.push('/');

const token = response.data.accessToken

return true;

} else {

if (message === "비밀번호가 일치하지 않습니다.")

setError("로그인 실패. 다시 시도해주세요.");

return false;

}

} catch (err: any) {

setError("로그인 실패. 다시 시도해주세요.");

console.error("Login error:", err.message);

return false;

}

};

return { form, error, handleChange, handleSubmit };

로그인 성공 처리하는 훅함수이고, 이것은.... 훅함수가 리턴한 데이터를 저장하는 store야. "//zustand에 저장" 부분에 스토어로 보내는 디스패치 로직을 작성하고, 스토어 부분도 필요하면 맞게 수정해줘.


......




