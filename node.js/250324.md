
- variable: 변화 가능한 지점
- state: 변화가 끝난 지점(state)에서 영속적으로 저장(redux에)하고 싶다. 


- oop에서는 "객체는 기능과 속성의 집합이다."
- 오라클에서의 객체는 아톰이다.(더이상 쪼갤 수 없는 1가지 기능을 가진...)
-  form이 아톰이니까 최소이다.
- 기본적으로 기능을 가지고 있다.
폼의 자식이 인풋이다. onchange는 자식꺼이다. 
form에는 onsubmit이 있다.

스레드와 메소드는 그 가치를 갖는다. 선언되지 않은 메소드와 호출된 스레드를 생각해야해.

작동되지 않는 ts와 , 호출된 ts가 있다. ?

롤백? 

이벤트가 쓰레드이고, 이벤트도 스톱되어있을 때와 작동할 때가 있다.

활성화 된 것과 활성화 되지 않은 것의 ...

이벤트 버블링????


form태그는 기능적으로 


속성명이 똑같아야 백엔드로 전달이 가능하다.

베러블은 상태가 전단된다. 

쌈마이디비: 7일간 쇼핑몰에 장바구니에 저장되어있다가 그 뒤에 사라지는 것.

사과나 야블라코나 애플이나 공통적으로 가진 이미지가 있다. 우리는 이걸 오브젝트라고 한다.


함수도 객체이다. 함수 안에 이너함수와 아웃함수로 나뉜다.


object의 문맥적 파악
- html에서 오브젝트는 form이다.
- 오라클에서 오브젝트는 아톰이다.
- 파이썬에서 오브젝트는 기능과 속성의 집합니다.

아톰에서의 값이 다 차였을 때, 


값이 안들어왔을때, state가 없는 것이다. 

값이 다 안들어왔을 때는 state가 아니다. state는 값이 다 차야되는 상황이다.

아톰의 요소 값이 변화를 종료하고, 객체 안으로 주입 되어야 이게 state 상태이고, submit 버튼을 누를 수 있다.

submit을 누르면 stateful이 된다.


sideeffect 때문에 무상태 프로그래밍을 사용하고 있다.

로그인과 회원가입을 할 때, 상태 관리자 없이도 충분히 구현 가능 하지만, 상태관리자를 이용해야한다.  


애자일에서 함수형 프로그래밍

ststaful과 stateless의 차이점

less와 
serverless:


stateful:


submit버튼을 누르기 전과 후로 나뉠때, 

submit 버튼을 누르기 전에는  no state 이고, submit 버튼을 누르고 나서는 stateful과 stateless로 나뉠 수 있다.


필요할 때만 상태가 존재하고, 필요하지 않을 때, 상태가 존재하지 않아야 한다.

hook 안에 state가 존재한다. 

useState

변수ㅡ는 벨류를 할당한 값이다.


슈뢰딩거 고양이(1935) - 상자를 열기 전까지 고양이가 살아있는 상태와 죽어있는 상태로 공존하고 있다. 라는 이야기로 유명함.

에로우 함수: 존재하지 않다가 호출되면 나오는 것...

사용자의 상태를 추적하고, , 

베러블은 변하는 공간

variable과 const

변화가 끝난 지점에서

변수와 상수와 상태의 차이점:?

변수: 

상수:

상태: 상태는 상태 유지(Stategul), 상태 유지하지 않음(Stateless)으로 나뉨. 

일단, 상태는  변화가 일어나는 게 맞아. 


서버(fastAPI)가 클라이언트(Next.JS)의 상태를 보존함.

stateless: 서버가 클라이언트의 상태를 보존하지 않음을 의미함.


storage - 영속적인 저장소가 아니다. state 개념이 여기서 존재한다. 

퍼시스턴스 - 영속성......

c(클라이언트) ~ s(서버)사이 : axios부터 라우터까지 사이를 의미함.


### 노드와 엣지?

- 노드와 노드 사이를 연결하는 것을 엣지라고 한다.

상태관리자가 없으면 어떤 상태가 되나요?


브라우저으 ㅣ쿠키에 저장되거나., 서버의 세션 메모리에 저장되어 상태를 유지하게 된다?

## 🔍 객체 지향 프로그래밍(OOP)은 유상태일까? 무상태일까?

👉 **객체 지향 프로그래밍은 본질적으로 _"유상태(stateful)"**입니다.


지금 그러나 무상태로 싹다 갈아 엎어야한다.


요즘은 OOP와 무상태 기반을 많이 사용한다. 


왜 지금은 무상태 기반을 사용해? 인공지능을 사용하기 때문에, 인공지능은 
사용자마다 채울려면 비워져 있어야 한다. 클라이언트가 정보를 가지고 있어야한다.


내 정보를 서버가 가지고 있을가? 아니면  디스크에 있다.

브라우저는 클라이언트꺼이다. 


요약:

상태:

상수:


특정 시점에서 컴포넌트에 저장된 시점 - state

## ✅ ACID란?

**ACID**는 데이터베이스 트랜잭션에서 **꼭 지켜져야 하는 4가지 원칙**을 말해요:

> 📦 **A**tomicity (원자성)  
> 🧪 **C**onsistency (일관성)  
> 🔁 **I**solation (고립성)  
> 💾 **D**urability (지속성)

---

## 🔍 하나씩 쉽게 설명해볼게요

### 1️⃣ **Atomicity (원자성)**

> 트랜잭션은 **모두 성공하거나, 전부 실패해야** 한다.

📦 예시:

- 은행에서 계좌 이체할 때  
    "A 계좌 출금 + B 계좌 입금"은 **둘 다 되거나, 둘 다 안 돼야 함**
    

---

### 2️⃣ **Consistency (일관성)**

> 트랜잭션 전후에 **데이터의 규칙(제약조건)**이 항상 지켜져야 한다.

📦 예시:

- 나이(age)는 0 이상이어야 함
    
- 근데 트랜잭션 후에 -1이 들어갔다? ❌ → **일관성 깨짐**
    

---

### 3️⃣ **Isolation (고립성)**

> 동시에 여러 트랜잭션이 실행돼도, **서로 영향을 주지 않아야 함**

📦 예시:

- 내가 장바구니에 담는 중인데,
    
- 다른 사람의 결제 트랜잭션이 내 상품에 영향 주면 안 됨
    

---

### 4️⃣ **Durability (지속성)**

> 트랜잭션이 끝나면, 결과는 **영구적으로 저장되어야 함**

📦 예시:

- 상품 주문 성공 → 서버 꺼져도 주문 내역 살아 있어야 함
    
- 즉, 커밋(commit)된 데이터는 절대 사라지면 안 됨
    

---

## 💬 한 줄 요약

> **ACID = 데이터베이스 트랜잭션의 안전하고 신뢰성 있는 처리 약속!**  
> → 전원 꺼져도, 오류 나도, 동시에 처리돼도 **데이터는 항상 안전하게 관리**돼야 한다는 원칙이에요.

---

### ✨ 참고: 어떤 DB가 ACID 보장할까?

|DB|ACID 보장 여부|
|---|---|
|PostgreSQL|✅ 완전 보장|
|MySQL (InnoDB)|✅ 보장|
|MongoDB|✅ (버전에 따라 부분 보장)|
|Redis|❌ 메모리 기반이라 약간 위험함 (옵션에 따라 다름)|

**"localStorage"**는 웹 개발에서 자주 쓰이는 **브라우저 저장소**예요.  
말 그대로 브라우저 안에 **데이터를 '로컬'에 저장**하는 공간입니다!


쿠키 허용이 되면 자기 정보가 털리는 거야.


스토어에서 정보가 있는지 없는지 .....미리 보내서 상태의 변화가 있는지 없는지 확인하려면 어떻게 해야하나?

서버- 스테이트 풀이다.
테이블 - 스테이트 풀이다. 

변수와 상수가 모여서 상태가 되는 지점까지  우리는 공부를 하였다.

상태가 저장된 다음부터 변할 수 있다. 이때, 유상태(stateful)와 무상태(stateless)로 나뉠 수 있다.
서버- 스테이트 풀이다.
테이블 - 스테이트 풀이다. 


oop는 객체지향이기 때문에, stateful이다.
oop는 stateful이고, fp는 stateless이다.

stateful로 되어있는 부분은 oop로 짜야한다. (라우터에서 entity까지). 서버는 스테이트 풀로 해야한다.



값이 변하면 안되는데, 변경은 있어야한다.  --> 이렇게 되려면,,, 안에 있는 값이 어떻게 하면 바뀔 수 있을까? 
내용물이 바뀌었는데, 바뀐게 아니다.




그러면 stateful인 지점에서 stainless로 바뀌는 지점....

여기에서는 stateful인 상태이다. (백엔드 -repository인 지점에서)
![[Pasted image 20250324160035.png]]

그리고 아래는 stateless인 상태이다.






상태의 부모가 있어? 

상태는 변수일 수 도 있고, 상수일 수 도 있다. 계속 const와 let으로 말하면서 

상태 관리자는 immutable이다. 

상태의 부모는  유기체이다.

상태는...?


클라이언트와 서버간의 통신을 상태유지(stateful)하느냐 상태유지를 하지 않느냐(stateless)..


유기체 - input 여러 개.



아톰 - input 한 개 


1번, 4번 스테이트 풀 (내부에서 상태를 가지고 있는 것을 의미함)


### stateful vs stateless의 차이점

노드가 상태를 갖고 있다. 

stateful: 상태가 ful이라는 것은 노드와 노드의 값이 같다.

stateless: 상태가 less라는 것은 노드와 노드의 값이 서로 다르다라는 것을 의미한다.

변수가 조직된 게 상태이다.



안의 값은 같은데, 바깥이 다르지만, 그것을 같은 객체로 본다.....???

속성 값들을 보고서 이게 뭔지를 안다. 
예를 들어, 내가 눈을 감고 , 만지고서 듣고서 추론하는거다. 이게 고양이다.라고 추측 왜냐 보지는 않았지만, 야옹이라고 울었고, 꼬리는 길다...라고 만졌기 때문에. 처음엔 고양이 이렇게 생겼어. 라고 알려주고, 나중에 추측하는 거다. 이게 고양이라고 나중에 추측...


노드 두 개가  stateful을 갖고 있다는 것은 --> 같은 객체는 아니다. 

state은 뭐지? 

속성들만 모아도 객체가 된다. 속성 가지고 추론 가능해져야 한다.
최소한의 속성을 가지고 추론 가능 해져야 한다. 이 상태가 state이다.



이미지 4개 순서대로 (1번, 2번, 3번, 4번)

대문자로 되어 있는거 보니까 이름이 있다는 것을 알 수 있다. 
![[Pasted image 20250324150507.png]]

2. 화면에서 받았던 녀석.
![[Pasted image 20250324150545.png]]
3. 
![[Pasted image 20250324150552.png]]

4번. 얘가 스키마이고, 엔터티이다. 서버로 보낼 애들만 추려서 재구성하였다. 
![[Pasted image 20250324150610.png]]


useState : 상태가 될 놈들만 뽑는다. 

인터페이스: 상태의 타입을 지정해주는, 상태가 되기 위한 최소한의 조건을 의미함.


클래스: 


두 노드 사이의 동일한 상태(변수와 변수 값)를 갖고 있으면 stateful이고, 동일한 상태를 갖고 있지 않으면 stateless이다.  

이름이 있으면 인스턴스... 이름을 준다는 것은 메모리를 먹는다는 것을 의미함.

덕스 패턴에 어긋난다. 

외부의 저장소를 놔두고 데이터를 주고 받고, 주고 받고 이게 stateful방식이다. stateful 방식은 oop 방식이다.


상태는 컨텍스트에(CTX) 따라 따른 값이다. 외부 클라이언트가 값을 입력하는 것을 컨텍스트라고 하고, 

외부 클라이언트가 입력하는 값이 여러개의 값이니까.


리덕스: 상태 관리자이다. 쇼핑몰 쪽에 가깞다. 많이 무겁다.

우리는 빨라야 한다.


리덕스: 상태 관리자

데이터베이스 관리 시스템: 데이터베이스를 운영하고 관리하는 소프트웨어

데이터베이스는 데이터의 집합

데이터: 정보를 가공하기 전.... 상수이다. 

데이터 관리자: 데이터를 관리하는 역할

상태란?
- 로컬(클라이언트)에서 생성하고 사용하고 있지만, 서버에 저장되지 않은 값을 의미함. 이건 stateless


서버전에는 데이터르 ㄹ베러블... 프롭스이다. 베러블의 모임은 프롭스이다.



### 상태를 직접 바꾸지 못하고, 액션 객체(entity)에서 만 상태를 바꿀 수 있다. 



state와 data를 같은 느낌으로 봐도 된다. 


아래는 store에 저장되는 것이다.
![[Pasted image 20250324163602.png]]

1번 체크
![[Pasted image 20250324164958.png]]

2번체크(얘네는 값을 줬다. )
![[Pasted image 20250324165029.png]]

3번 쳌,

![[Pasted image 20250324165058.png]]

4번 체크

클라이언트 정보 요청에 따라 연결된 스테이트로 만들어져 있는데, 스테이트와 store에 저장할 스테이트가 연결되었을때, sideeffect가 발생했을 때, 

![[Pasted image 20250324165147.png]]

이름이 없는 것을 리퀘스트 바디라고 한다.




--=
1. DB르 ㄹ먼저 보고, 
![[Pasted image 20250324175559.png]]






