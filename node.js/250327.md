인풋하면 헨들체인지 잓동하고 유즈스테읻트로 작됭되고 유즈스테이트에서 인풋에서 입력한 값들이 폼이 만들어지는 과정에서 점점점 으로 루프되고


인풋에서 핸들체인지 걸려서 유즈


빌드되면 호이스팅이 일어난다. 

상태가 초기화되고, 폼에 들어가서 

이제 인풋이 들어간다.. 온쳉;ㄵ; 들어가서 온체인지 일어나서 핸들체인지가 움직인다. 그 다음 루프가 돈다. 상태가 변화하는 과정이 있다. --> 이걸 업데이트라고 한다.  스프레이드 오퍼레이드.. 인풋한 값들이 계속 인풋해서 폼에 들어가고, 폼에 들어가서 ... 변하는 순간에만 존재하고, 에로우 펑션하면 로컬에서만 작동한다. 


펑션 ... 호이스팅...
에로우 펑션... 


콜백함수는 평소에 없다가 필요할 때 호출되면 



유즈 붙은 함수는 화면이 끝날때까지 계속 있고, '
'
아래 함수는 에로우 함수가 있는데, 이건 콜백함수라고 했고, 콜백함수는 필요할 때만 호출당한다고 했다. 평소에는 없다가....
에로우 펑션은 필요할 때만 쓰고, 입력할때마다 작동만....


이메일과 패스워드는 눈에 보이지... 


호이스팅으로 대문자 펑션인게 좌알 올라오고 훅은 어떻게 올라오면 ...
훅함수 부분은 

인풋시작하면 

에로우 펑션 작동할 땜ㄴ...

target: 소비자가 입력하는 창....


상태가 업데이트되면서 폼에 들어오고 키와 벨류가 채워진다. 




상태도 객ㅊ


상태가 업데이트된다. --> 상태속성이 바뀐다.


상태란, 유즈 스테이트가 초기화하면서 ... 유즈 스테이트가 생성한다.........



훅함수 -->


컴포넌트

호이스팅: 전역에서...

1. 함수가 호출 당하면 전역과 로컬에서 어떤 기능을 하냐?(함수 호출 당하는 것)


호출 하는 건:  노드

두개의 노드가 만들어지면 엣지가 만들어지고, 관ㅖ가  

Oop에서의 관계: 4가지만 있다. (연관, 의존, 집합, 구성)

부모 자식 관계 : 상하관계가 만들어진다.

위에서 아래로. 

A -- B

(단방향)

상속: 속성만 내려간다.

상속: 속성의 이동이다.
호출: 기능의 이동이다..

한쪽이 자연의 이치이다.

MVC: 양방향이다.

리듀서: 단방향이다.

상속: 속성은 디엔에이같은거다. 전역이니까

호출:  

기능: 부모한테 있는 것을 갖다가 사용하는 구조가 되어진다.


도메인이 붙은 녀석이 하나의 큰 객체에요.

전역은 네이버 닷컴이다.

빌드: 실행 가능한 상태로 만드는 것이다.



빌드 다음이 배포이다. 

호출 당한다는 표현: 부모자식간의 관계가 만들어진다. 


전역: 도메인 전체이고, 

로컬: 페이지이다. 


리엑트에서 전역 범위: app, componet, hook

app(객체가 될 수 있다) = component(속성) + hook(기능)

리엑트에서 전역은 app이다.

store도 전역이다. 

app과 store은 시블링관계이다. 시블링관계에서는 수평관계이다. 시블링은 데이터를 의존으로 주고받는다. 

디비를 줄 때 디펜스 의존관계를 뜻한다. 


FastAPI와 NextJS는 시블링 관계이다. 데이터를 의존관계로 주고 받는다. 


의존하는 객체에서 의존의 대상이 되는 객체 쪽으로 향하는 화살표로 표현합니다.






FastAPI가 DB에 의존하고 있다. 왜냐하면 DB가 먼저 있어야 하고, 기능을 수행할 수 있으니까. 

부모 자식 관계에서 상속(속성)과 호출(기능)로 데이터를 주고 받는다. 

양방향성: FastAPI와 NextJS의 관계는 서로 달라진다.

콜: 호출한다. 부모자식관계라는 것을 알 수 있다. 콜(호출)이라는 것은 자식이 부모에게 기능 달라고 말하는 것이다.


flux 패턴: 양방향으로 처리했던 것을 단방향으로 처리한다.




store: 리덕스의 땅이다.  미국대사관 느낌이다. 여긴 전역에 포함되지 않는다. 

컴포넌트: 속성

훅: 기능

컨테이너 <-- 컴포넌트 <-- 훅

컴포넌트가 훅을 호출(기능)한다. 

component use UseLoginForm...


```
export default function useLoginForm() {

  const [form, setForm] = useState<LoginFormState>({

    email: "",

    password: "",

  });
```

[form, setForm] = useState이라는 말은 즉, form이 email과 password를 상태(속성값)로 사용한다니까.  중괄호는 삼다수 병(상태 객체)이다. form은 껍데기이다. 


axios를 통해서 백엔드에 보냈다가 다시 왔어. 

자바스크립트에서 



e가 들어가야 파라미터로 사용할 수 있다. 

제어의 역전: 의존관계가 에이에서 비로 되어있었는데, b에서 a로 바뀌었고, 양방향성이 되게 코딩을 하는 순간이 온다.


어디 올라가서 실행되느게 아니라 거기에서만 실행된다. 


시블링관계에서는 호출이 안된다. 

콜백함수: 각자의 역할이 다르게 "갑 을 병 정 순으로 간다. 그리고 정 병 을 갑으로 "

콜백함수 2가지 구분

버블링: 밑에서 위로(자식 --> 부모)

캡쳐링: 위에서 밑으로(부모 --> 자식)

e(객체).target(객체).name(변수)


버블링은 사이드이팩트를 가진다.

그 부분에서만 쓰고 마는 것


q. export type UserType = { user_id: string; email: string; name: string; setUser: (user: PartialUserType) => void; reset: () => void; } 현재 zustand의 type선언이야. 최신 버전으로 state와 action으로 변경된 코드로 수정해줘.

###### ChatGPT의 말:

현재 상태를 최신 Zustand 버전 (v4.x)을 기준으로, **`state`**와 **`action`** 분리된 방식으로 수정한 코드입니다. Zustand v4에서는 `state`와 `action`을 분리하여 선언할 수 있습니다. 이 방식을 사용하면 상태 관리가 더 명확해지고, 코드도 깔끔하게 유지됩니다.




콜백 지옥 일때, 중첩함수가 일어남....

근데 함수가 아니라  벨류만 처리한다. 


많은 사람들이 중첩된 값을 업데이트할 때 Immer를 사용합니다. Immer는 React, Redux는 물론 Zustand에서도 중첩된 상태를 업데이트해야 할 때 언제든지 사용할 수 있습니다!

Immer(불변 객체에 대한 속성 값을 바꾸는 것)를 사용하면 깊게 중첩된 객체에 대한 상태 업데이트 시간을 단축할 수 있습니다. 


슬라이스 패턴: 크기, 똑같은 모양으로 쪼갠다. 그러면 안의 속성 값이랑 기능이 똑같아.

더이상 늘어나지 않고, 쏙 뽑아서 주는 거다. 근데 뭘 뽑든 다 똑같아. 뽑아서 뭘 주는거야?/...뭘 분리시키는걸까>




zustand에 있는 스테이트는 스토어에 장판처럼 쫘악 깔려있고, 스테이트는 쪼갤 수 없고, 스토어는 슬라이스로 쪼갤 수 있다. 
state


스토어에있는 스테이트와 리엑트에 있는 스테이트는 같을까?

주스텐트는 글로벌 스테이트가 없다. 

리엑트 입장에서는 스테이트가 곧 글로벌 스테이트이다. 

스토어에 있는 모든 스테[이트는 모두 로컬 스테이트이고, 리엑트입장에서 스테이트는 글로벌 스테이트만 본다. 즉 최상단의 스토어만 본다. 


## 🛠️ Zustand의 `devtools`는?

> **Redux DevTools Extension**과 연동해서 상태 변경을 시각적으로 추적할 수 있게 해주는 미들웨어예요.

Zustand는 Redux와 비슷하게 작동하니까, Redux DevTools를 그대로 활용할 수 있어요. 이때 `devtools()` 미들웨어를 사용해서 상태의 변화, 액션 호출 등을 **개발자 도구에서 확인**할 수 있게 해줍니다.


![[Pasted image 20250327170352.png]]


![[Pasted image 20250327172120.png]]

```
dddddd
```


오늘 배운 내용을 정해보면 우리는 오늘 state에 대해 다시 배웠다.

store에는 찐 state가 있고, 훅에 있던 useLoginForm에 있던 state들은 다 가짜가 되었고, 이렇게 되면서 state가 사라졌으므로, stateless 상태가 되었다. 그리고 useLoginForm을 우리는 걔들을 콜렉터라고 부르기로 했다. 그리고 Store에 있는 애들은  useLoginForm에 collector의 일부분을 줬다. 그리고 Store는 useLoginForm이라는 애들을 관찰하기만 한다. Store는 useLoginForm의 구독자이다. 

state는 한 개이고, 쪼갤 수 없다고 했다. 

![[Pasted image 20250327175635.png]]



![[Pasted image 20250327175733.png]]


내가 뭐라고 말했냐면 sellector는 특정함수만 갈아끼는거야... .바뀐 부분만.....
특정함수 셀렉터는 아래와 같고,,,
```JavaScript
export default function useLoginForm() {

  const [form, setForm] = useState<LoginFormState>({

    email: "",

    password: "",

  });
```

그래서 .... 
로그인이 성공되면 아래 코딩이 구현이 된다.

이 부분
```
const setUser = useAuthStore((state) => state.setUser); // ✅ Zustand의 setUser 가져오기
```

근데 여기서 보니까.... 이건 콜백함수를 쓰고있어. 콜백함수는 내가 자신이 직접 제어를 하는게 아니라 누구를 시켜서 간접적으로 제어하는건데, useAuthStore라는 제어기를 통해서 하는거 같아. 그리고 Zustand에서 즉,,,,store에서  state
