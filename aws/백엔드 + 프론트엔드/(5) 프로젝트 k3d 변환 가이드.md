
알겠습니다! GitHub의 aws3 프로젝트를 k3d를 사용하여 Kubernetes 환경으로 전환하는 과정을 상세히 안내해 드리겠습니다. Windows 환경 기준으로 설명하며, 로드 밸런싱과 스케일 아웃(레플리카 설정)을 포함합니다.

**진행 순서:**

1. **사전 준비물 설치 (Windows)**
    
2. **프로젝트 분석 (docker-compose.yml 활용)**
    
3. **각 서비스별 Dockerfile 준비 (필요시)**
    
4. **Docker 이미지 빌드**
    
5. **k3d 클러스터 생성 및 이미지 임포트**
    
6. **Kubernetes Manifest 파일 작성 (Deployment, Service)**
    
7. **애플리케이션 배포 및 확인**
    

---

**1. 사전 준비물 설치 (Windows)**

이미 git은 사용하고 계시니, 다음 도구들이 필요합니다. PowerShell 또는 CMD에서 진행합니다.

- **WSL2 (Windows Subsystem for Linux 2):** Docker Desktop이 WSL2 백엔드에서 실행될 때 k3d가 가장 잘 동작합니다.
    
    - PowerShell (관리자 권한) 에서 wsl --install 실행 후 재부팅. (이미 설치되어 있다면 생략)
        
    - Microsoft Store에서 원하는 Linux 배포판 (예: Ubuntu) 설치.
        
- **Docker Desktop for Windows:**
    
    - [공식 사이트](https://www.google.com/url?sa=E&q=https%3A%2F%2Fwww.docker.com%2Fproducts%2Fdocker-desktop%2F)에서 다운로드 및 설치.
        
    - 설정에서 "Use the WSL 2 based engine" 옵션이 활성화되어 있는지 확인합니다.
        
- **k3d:** 경량 Kubernetes 클러스터를 로컬에 쉽게 생성해주는 도구입니다.
    
    - Chocolatey 사용 (추천): choco install k3d
        
    - Scoop 사용: scoop install k3d
        
    - 수동 설치: [k3d GitHub Releases](https://www.google.com/url?sa=E&q=https%3A%2F%2Fgithub.com%2Fk3d-io%2Fk3d%2Freleases)에서 k3d-windows-amd64.exe 다운로드 후, k3d.exe로 이름 변경하고 PATH에 추가.
        
- **kubectl:** Kubernetes 클러스터와 통신하기 위한 CLI 도구입니다.
    
    - Docker Desktop 설치 시 함께 설치되는 경우가 많습니다.
        
    - 설치 확인: kubectl version --client
        
    - 만약 없다면: choco install kubernetes-cli 또는 [공식 문서](https://www.google.com/url?sa=E&q=https%3A%2F%2Fkubernetes.io%2Fdocs%2Ftasks%2Ftools%2Finstall-kubectl-windows%2F) 참고.
        

**2. 프로젝트 분석 (docker-compose.yml 활용)**

C:\Users\bitcamp\aws3 디렉토리에 있는 docker-compose.yml 파일은 Kubernetes로 전환하는 데 매우 중요한 정보를 담고 있습니다. 이 파일을 열어 각 서비스의 다음 정보들을 파악해야 합니다:

- **서비스 이름:** (예: frontend, gateway, issuepool-service 등)
    
- **사용하는 이미지:** (직접 빌드하는 경우 build 컨텍스트, 외부 이미지인 경우 이미지 이름)
    
- **포트 매핑:** (예: 8080:80 -> 컨테이너 포트 80, 호스트 포트 8080)
    
- **환경 변수:** (Kubernetes Secret 또는 ConfigMap으로 관리될 수 있음)
    
- **볼륨:** (Kubernetes PersistentVolume, PersistentVolumeClaim으로 대체)
    
- **의존성:** (depends_on - Kubernetes에서는 서비스 디스커버리로 해결)
    

예시로 gateway 서비스를 가정해 보겠습니다. docker-compose.yml에 다음과 유사한 내용이 있을 수 있습니다:

```
services:
  gateway:
    build: ./gateway # Dockerfile 위치
    ports:
      - "8000:8000" # 호스트 포트 8000 : 컨테이너 포트 8000
    environment:
      - SPRING_PROFILES_ACTIVE=default
      - NEWS_SERVICE_URL=http://news-service:8081 # 서비스 간 통신 URL
    # ... 기타 설정
```

이 정보를 바탕으로 Kubernetes Manifest를 작성합니다.

**3. 각 서비스별 Dockerfile 준비 (필요시)**

프로젝트 루트에 Dockerfile이 하나 있지만, 이는 특정 서비스(아마도 frontend 또는 단일 서비스용)를 위한 것일 수 있습니다. 각 마이크로서비스(gateway, issuepool-service 등)는 자신만의 Dockerfile을 가지는 것이 일반적입니다.

- frontend/Dockerfile
    
- gateway/Dockerfile
    
- issuepool-service/Dockerfile
    
- ... 등등
    

만약 각 서비스 폴더 내에 Dockerfile이 없다면, 해당 서비스의 기술 스택(Spring Boot, Node.js 등)에 맞게 생성해야 합니다. docker-compose.yml의 build 항목을 참고하여 Dockerfile의 위치와 컨텍스트를 확인하세요.

**예시: Spring Boot 서비스용 Dockerfile (예: gateway/Dockerfile)**

```
FROM openjdk:17-jdk-slim as builder
ARG JAR_FILE=build/libs/*.jar
COPY ${JAR_FILE} application.jar
RUN java -Djarmode=layertools -jar application.jar extract

FROM openjdk:17-jdk-slim
COPY --from=builder dependencies/ ./
COPY --from=builder spring-boot-loader/ ./
COPY --from=builder snapshot-dependencies/ ./
COPY --from=builder application/ ./
ENTRYPOINT ["java", "org.springframework.boot.loader.JarLauncher"]
```

**4. Docker 이미지 빌드**

각 서비스의 Dockerfile이 준비되었다면, 이미지를 빌드합니다. 프로젝트 루트(C:\Users\bitcamp\aws3)에서 PowerShell을 열고 다음 명령을 실행합니다.

- docker-compose.yml에 정의된 모든 서비스를 빌드:
```
docker-compose build
```

- 또는 각 서비스별로 빌드 (이미지 이름을 명시적으로 지정하는 것이 좋음):
```
cd gateway
docker build -t gateway-service:latest .
cd ..

cd news-service
docker build -t news-service:latest .
cd ..

# ... 나머지 서비스들도 동일하게 빌드
# frontend는 Node.js 기반일 수 있으므로 Dockerfile 내용이 다를 것입니다.
# 예: cd frontend
#     docker build -t frontend-app:latest .
#     cd ..
```

- **중요:** 이미지 이름은 Kubernetes Manifest에서 사용할 이름과 일치시켜야 합니다. latest 태그 대신 버전 번호를 사용하는 것이 좋습니다 (예: gateway-service:v1.0).
    

**5. k3d 클러스터 생성 및 이미지 임포트**

- **k3d 클러스터 생성:**  
    aws3 프로젝트의 외부 진입점(일반적으로 gateway 또는 frontend)이 사용할 포트를 k3d 클러스터 생성 시 호스트와 매핑합니다. 예를 들어, 게이트웨이가 8000번 포트를 사용하고 이를 로컬 PC의 8000번 포트로 접근하고 싶다면:

```
k3d cluster create aws3-cluster --api-port 6443 -p "8000:80@loadbalancer" --agents 2
```


- - aws3-cluster: 클러스터 이름 (자유롭게 지정)
        
    - --api-port 6443: Kubernetes API 서버 포트를 호스트의 6443에 노출 (kubectl이 사용)
        
    - -p "8000:80@loadbalancer": 호스트의 8000번 포트를 k3d 내부 로드밸런서의 80번 포트로 전달. (만약 게이트웨이가 8080을 쓴다면 -p "8080:80@loadbalancer")
        
    - --agents 2: 2개의 워커 노드를 생성 (스케일 아웃 테스트용)
        
- **빌드한 Docker 이미지를 k3d 클러스터로 임포트:**  
    로컬에서 빌드한 이미지를 k3d 클러스터 내부에서 사용할 수 있도록 임포트합니다.

```
k3d image import gateway-service:latest -c aws3-cluster
k3d image import news-service:latest -c aws3-cluster
k3d image import issuepool-service:latest -c aws3-cluster
# ... 빌드한 모든 서비스 이미지를 임포트
k3d image import frontend-app:latest -c aws3-cluster
```


**6. Kubernetes Manifest 파일 작성 (Deployment, Service)**

C:\Users\bitcamp\aws3\k8s 폴더에 각 서비스별로 Deployment와 Service YAML 파일을 작성합니다.

**기본 구조:**

- **xxxx-deployment.yaml**: Pod의 배포 방식, 레플리카 수, 사용할 이미지, 포트, 환경 변수 등을 정의합니다.
    
- **xxxx-service.yaml**: Deployment로 생성된 Pod들에 접근할 수 있는 안정적인 네트워크 엔드포인트(IP, DNS)를 제공합니다. 서비스 간 통신 및 외부 노출에 사용됩니다.
    

**예시: k8s/gateway-deployment.yaml**

```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: gateway-deployment # Deployment 이름
  labels:
    app: gateway # 이 Deployment를 식별하는 레이블
spec:
  replicas: 2 # 스케일 아웃! 원하는 파드 수 (로드밸런싱 대상)
  selector:
    matchLabels:
      app: gateway # 이 레이블을 가진 Pod를 관리
  template:
    metadata:
      labels:
        app: gateway # Pod에 적용될 레이블
    spec:
      containers:
      - name: gateway-container # 컨테이너 이름
        image: gateway-service:latest # 4번 단계에서 빌드한 이미지 이름
        ports:
        - containerPort: 8000 # 컨테이너 내부에서 애플리케이션이 사용하는 포트
        env: # docker-compose.yml의 environment 참고
        - name: SPRING_PROFILES_ACTIVE
          value: "kubernetes" # k8s 환경용 프로파일 (예시)
        - name: NEWS_SERVICE_URL
          value: "http://news-service:8081" # Kubernetes 내부 서비스 DNS 이름 사용
        # 필요한 다른 환경 변수 추가
        # livenessProbe, readinessProbe 추가 권장 (헬스 체크)
        # resources (limits, requests) 설정 권장
```

예시: k8s/gateway-service.yaml

```
apiVersion: v1
kind: Service
metadata:
  name: gateway-service # 서비스 이름 (다른 서비스가 이 이름으로 gateway에 접근)
  labels:
    app: gateway
spec:
  selector:
    app: gateway # 'gateway-deployment'의 Pod 레이블과 일치해야 함
  ports:
  - protocol: TCP
    port: 80 # k3d 클러스터 생성 시 -p "8000:80@loadbalancer"의 내부 포트와 일치
    targetPort: 8000 # gateway-container의 containerPort와 일치
  type: LoadBalancer # 외부에서 접근 가능하도록 k3d의 로드밸런서 사용
                     # k3d에서는 이 타입이 실제 클라우드 LB가 아닌 k3d 내부 LB와 연결됨
```

**참고:** gateway-service의 port는 k3d 클러스터 생성 시 -p "호스트포트:로드밸런서포트@loadbalancer" 에서 로드밸런서포트와 일치해야 합니다. 위 예시에서는 80으로 설정했습니다.

**예시: k8s/news-service-deployment.yaml (내부 서비스)**

```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: news-deployment
  labels:
    app: news
spec:
  replicas: 2 # 스케일 아웃
  selector:
    matchLabels:
      app: news
  template:
    metadata:
      labels:
        app: news
    spec:
      containers:
      - name: news-container
        image: news-service:latest
        ports:
        - containerPort: 8081 # news-service가 사용하는 내부 포트
        env:
        # ... news-service에 필요한 환경 변수
```


예시: k8s/news-service-service.yaml (내부 서비스)

```
apiVersion: v1
kind: Service
metadata:
  name: news-service # 다른 서비스가 이 이름 (news-service)으로 접근
  labels:
    app: news
spec:
  selector:
    app: news
  ports:
  - protocol: TCP
    port: 8081 # 서비스가 노출할 포트 (gateway에서 news-service:8081로 접근)
    targetPort: 8081 # news-container의 containerPort
  type: ClusterIP # 클러스터 내부에서만 접근 가능 (기본값)
```


**Frontend 서비스 예시 (k8s/frontend-deployment.yaml, k8s/frontend-service.yaml)**

- **frontend-deployment.yaml**: image: frontend-app:latest, containerPort는 frontend가 사용하는 포트 (예: 3000 또는 80)
    
- **frontend-service.yaml**:
    
    - 만약 gateway를 통해 API만 호출하고 frontend는 별도 진입점이라면, gateway-service처럼 type: LoadBalancer로 설정하고 k3d cluster create 시 포트 매핑을 추가해야 합니다 (예: -p "3000:80@loadbalancer").
        
    - 만약 gateway가 frontend의 정적 파일까지 서빙한다면 frontend-service는 필요 없거나 ClusterIP로 충분할 수 있습니다.
        
    - 일반적으로는 frontend도 LoadBalancer 타입의 서비스를 갖거나, Ingress를 통해 gateway와 함께 라우팅됩니다. k3d는 기본적으로 Traefik Ingress Controller를 포함하므로 Ingress를 사용하는 것이 더 고급 방법입니다. 여기서는 간단히 LoadBalancer로 가정하겠습니다.
        

**모든 서비스에 대해 xxxx-deployment.yaml과 xxxx-service.yaml 파일을 k8s 폴더에 생성합니다.**

- docker-compose.yml의 서비스 이름을 Kubernetes 서비스 이름 및 DNS 이름으로 사용합니다. (예: news-service가 http://news-service: port로 호출됨)
    
- 환경 변수에서 서비스 URL을 Kubernetes 서비스 이름으로 변경해야 합니다 (예: NEWS_SERVICE_URL=http://news-service:8081).
    

**7. 애플리케이션 배포 및 확인**

PowerShell에서 C:\Users\bitcamp\aws3 경로로 이동한 후 다음 명령을 실행합니다.

- **Kubernetes 컨텍스트 설정 (k3d가 자동으로 해주는 경우가 많음):**









### 명령어 관련:

docker ps = kubectl get pods